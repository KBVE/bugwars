---
title: Bug Wars - Game Design Document
description: Comprehensive technical documentation for the Bug Wars Unity game project
---

import { Card, CardGrid } from '@astrojs/starlight/components';

# Bug Wars - Game Design Document

## Game Overview

**Bug Wars** is a survival action game built in Unity where players face off against relentless waves of insects and creatures from the natural world. The game features intense combat mechanics, strategic resource management, and progressive difficulty scaling. Players must adapt to different bug types, each with unique behaviors and attack patterns, while managing limited resources and upgrading their defensive capabilities.

The game is built using modern Unity development practices, leveraging powerful architectural patterns through dependency injection (VContainer) and asynchronous programming (UniTask). The core architecture emphasizes modularity, testability, and clean separation of concerns, making the codebase maintainable and scalable as new features are added.

## Core Technologies

### VContainer - Dependency Injection Framework

[VContainer GitHub Repository](https://github.com/hadashiA/VContainer)

VContainer is the fastest and most lightweight dependency injection (DI) framework for Unity, providing a robust foundation for managing object lifecycles and dependencies throughout Bug Wars. Unlike traditional Unity development where components find each other using `FindObjectOfType` or singleton patterns, VContainer enables proper inversion of control (IoC) where dependencies are explicitly declared and automatically injected.

In Bug Wars, VContainer serves as the backbone of our architecture through the `GameLifetimeScope` class, which orchestrates all core managers (GameManager, EventManager, InputManager, etc.). This approach eliminates tight coupling between systems, makes testing easier through dependency mocking, and provides clear visibility into system dependencies. VContainer's constructor and method injection automatically resolves dependencies when components are created, ensuring that all required references are available before a component begins its work.

The framework's performance characteristics are crucial for games - VContainer generates optimal IL code at build time, resulting in zero reflection overhead at runtime. This makes it ideal for performance-critical game environments where every frame counts. Our implementation uses VContainer's `LifetimeScope` to manage singleton managers that persist across scenes, while still maintaining the flexibility to add scoped dependencies for level-specific systems.

### UniTask - High-Performance Async/Await

[UniTask GitHub Repository](https://github.com/Cysharp/UniTask)

UniTask is a zero-allocation async/await framework specifically designed for Unity, replacing Unity's older Coroutine system with modern C# async/await patterns. Unlike standard .NET Tasks which allocate garbage on every operation, UniTask is a value-type based implementation that provides true zero-allocation asynchronous programming, making it perfect for game development where garbage collection pauses can cause frame drops.

In Bug Wars, UniTask powers all asynchronous operations including scene loading, resource streaming, and complex animation sequences. The `GameManager` uses UniTask extensively for scene management, providing clean async/await syntax instead of callback-based coroutines. This makes our code more readable and maintainable - for example, loading a scene with progress tracking becomes a straightforward async method rather than a complex IEnumerator with nested callbacks. UniTask also integrates seamlessly with Unity's lifecycle, providing PlayerLoop-based task scheduling that respects Unity's frame timing.

The performance benefits of UniTask are substantial - it avoids the heap allocations associated with coroutines and standard Tasks, operates faster than Unity's coroutine system, and provides better debugging support through proper stack traces. UniTask also includes powerful operators for working with Unity's async operations, time-based delays, and cancellation tokens, giving us fine-grained control over asynchronous workflows. This is particularly important for Bug Wars' gameplay systems where we need responsive, non-blocking operations for enemy spawning, animation blending, and networked events.

### Cinemachine - Procedural Camera System

[Cinemachine Documentation](https://docs.unity3d.com/Packages/com.unity.cinemachine@latest)

Cinemachine is Unity's powerful procedural camera system that enables AAA-quality camera behaviors without complex manual scripting. Instead of writing custom camera controllers with follow logic, damping, and collision detection, Cinemachine provides a component-based approach where cameras are assembled from modular building blocks called Virtual Cameras. This shifts camera work from programming to design, allowing rapid iteration on camera feel and behavior.

In Bug Wars, Cinemachine serves as the foundation for all camera systems, providing dynamic camera control that responds to gameplay situations. The framework's Virtual Camera concept allows us to define multiple camera perspectives (combat camera, boss fight camera, death camera) and seamlessly blend between them based on game state. Each Virtual Camera can have its own priority, follow target, look-at target, and behavioral components, making it trivial to create context-sensitive camera work that enhances the player experience.

#### Key Features for Bug Wars:

- **Dynamic Follow & Framing**: Cinemachine's Body components (Transposer, Framing Transposer, Orbital Transposer) provide sophisticated player-following logic with customizable damping, dead zones, and screen composition rules. This ensures the player character stays optimally framed even during intense combat sequences.

- **Smart Aim Handling**: The Aim components manage where the camera looks, supporting hard look-at, composer-based framing, POV rotation, and more. For Bug Wars' combat scenarios, this allows the camera to intelligently frame both the player and approaching enemy threats.

- **Procedural Noise & Shake**: The CinemachineBasicMultiChannelPerlin component enables realistic camera shake for impacts, explosions, and damage feedback. Unlike manual shake implementations, Cinemachine's procedural noise is based on Perlin noise profiles, providing organic, non-repetitive camera movement that can be tuned with frequency and amplitude curves.

- **Collision Detection**: Cinemachine's Collider extension automatically handles camera collision with environment geometry, preventing the camera from clipping through walls or obstacles. This is crucial for Bug Wars' varied combat arenas where maintaining visibility is essential.

- **State-Driven Cameras**: Integration with Unity's Timeline and animation system allows camera cuts and blends to be choreographed alongside gameplay events. Boss introductions, player death sequences, and victory celebrations can all leverage cinematic camera work.

- **Input-Responsive Systems**: Cinemachine's input axes support player-controlled camera rotation, zoom, and positioning, enabling features like manual camera control during strategic moments or targeting specific enemies.

#### Performance & Architecture Benefits:

Cinemachine is designed for zero-garbage-collection camera updates, running all calculations on the same frame timeline as Unity's camera system. The framework uses a priority-based blending system where multiple Virtual Cameras can coexist, with the highest-priority camera taking control. Transitions between cameras use sophisticated blending algorithms that can interpolate position, rotation, and lens properties over time, creating smooth cinematic transitions without writing custom interpolation code.

For Bug Wars' architecture, Cinemachine integrates seamlessly with our existing VContainer and UniTask infrastructure. Virtual Cameras can be activated/deactivated in response to EventManager triggers (player death, boss spawn, wave completion), and camera transitions can be awaited using UniTask for precise sequencing. The component-based design also supports dependency injection - custom Cinemachine extensions can receive injected dependencies for accessing game state when making camera decisions.

The separation between Virtual Cameras (what you want to shoot) and the Brain (how to execute the shot) provides excellent testability and designer iteration. Camera behaviors can be tuned in the editor without code changes, and multiple camera setups can be A/B tested simply by adjusting priorities. This design philosophy aligns perfectly with Bug Wars' emphasis on clean architecture and rapid iteration.

## AI-Assisted Development with MCP

Bug Wars embraces modern AI-assisted development workflows through the Model Context Protocol (MCP), enabling seamless collaboration between human developers and AI assistants directly within the Unity environment. MCP provides a standardized interface for AI tools to interact with development environments, allowing for intelligent code suggestions, automated refactoring, asset management, and context-aware assistance throughout the development process.

By integrating MCP into our development workflow, we accelerate iteration speed, reduce repetitive tasks, and enable developers to focus on creative problem-solving and game design rather than boilerplate code generation. AI assistants can understand the project's architecture, suggest improvements aligned with our coding standards, and help maintain consistency across the codebase. This is particularly valuable for Bug Wars' complex systems involving VContainer dependency graphs, UniTask async patterns, and Cinemachine configurations.

### Unity MCP - AI Bridge for Unity Editor

[Unity MCP GitHub Repository](https://github.com/CoplayDev/unity-mcp)

Unity MCP is an open-source bridge that connects AI assistants (such as Claude, Cursor, and other LLM-powered tools) directly to the Unity Editor through the Model Context Protocol. This integration enables natural language control of Unity projects, allowing developers to leverage AI for automating workflows, managing assets, and accelerating game development tasks that would traditionally require manual editor interactions.

#### Architecture & Components:

Unity MCP consists of two complementary components that work together:

- **Unity Package**: Installed directly into your Unity project via Package Manager, this component exposes Unity Editor APIs and provides hooks into the project's scene hierarchy, asset database, and editor state.
- **Python Server**: A local server that runs alongside your development environment, facilitating bidirectional communication between your AI client and the Unity Editor. The server translates natural language commands into Unity API calls and returns structured responses.

#### Key Capabilities for Bug Wars Development:

**Asset Management**
- Import, create, modify, and delete project resources through AI commands
- Organize prefabs, scripts, textures, and audio files based on natural language instructions
- Automate batch asset operations (renaming conventions, folder restructuring, metadata tagging)

**Scene Manipulation**
- Load, save, and modify scene hierarchies conversationally
- Create and configure GameObjects with specific components and settings
- Adjust scene lighting, camera positions, and environment properties without manual editor navigation

**Script Creation & Editing**
- Generate C# scripts with proper namespace conventions and dependency patterns
- Modify existing code with AI-suggested improvements and refactoring
- Validate script syntax and integration with Unity's component system

**Workflow Automation**
- Execute repetitive Unity Editor tasks through natural language commands
- Automate testing sequences, build configurations, and deployment steps
- Query editor state to understand current selections, active windows, and project settings

#### Integration with Bug Wars Workflow:

Unity MCP enhances Bug Wars development by enabling AI assistants to:

- **Understand Architecture Context**: AI can analyze the VContainer dependency graphs and suggest proper injection patterns for new managers and controllers
- **Generate Cinemachine Configurations**: Describe desired camera behaviors in natural language and have the AI configure Virtual Camera components with appropriate settings
- **Create Event-Driven Code**: AI understands the EventManager pattern and can generate new events with proper trigger methods and listener subscriptions
- **Validate Unity Best Practices**: AI can review code for Unity-specific anti-patterns (improper lifecycle usage, expensive operations in Update loops, missing null checks) and suggest corrections

#### Setup Requirements:

For developers joining the Bug Wars project, Unity MCP setup involves:

1. Install the Unity package via Package Manager (Git URL or local package)
2. Configure the Python server with your AI client credentials
3. Ensure Python 3.8+ is installed with required dependencies
4. Launch the server alongside Unity Editor for active AI assistance

The system supports multiple simultaneous Unity instances and integrates seamlessly with popular AI coding clients, requiring minimal configuration beyond initial setup. For Bug Wars contributors, Unity MCP accelerates onboarding by allowing new developers to query the AI about architecture decisions, quickly generate boilerplate code following project conventions, and receive context-aware assistance when implementing new gameplay systems.

---

## Core Architecture

### GameLifetimeScope

**Location:** `Assets/Scripts/Core/GameLifetimeScope.cs`

The `GameLifetimeScope` is the central orchestrator for Bug Wars' dependency injection container, extending VContainer's `LifetimeScope` base class. This class is responsible for bootstrapping the entire game architecture by registering all core managers in their correct dependency order and ensuring they persist across scene transitions.

#### Key Responsibilities:

- **Dependency Registration**: Manages the registration of all singleton managers (EventManager, InputManager, GameManager, MainMenuManager) with the VContainer container
- **Initialization Order**: Ensures components are registered in proper dependency order - EventManager first (no dependencies), followed by InputManager (depends on EventManager), then GameManager and MainMenuManager
- **UI Configuration**: Handles the creation and configuration of UIDocument-based interfaces, including PanelSettings and VisualTreeAssets for the main menu system
- **Runtime PanelSettings**: Intelligently creates default PanelSettings at runtime if none are assigned, ensuring UI rendering works correctly even without manual configuration
- **Lifecycle Management**: Marks core managers with `DontDestroyOnLoad()` to persist across scene transitions, maintaining game state throughout the player's session

The `RegisterOrCreateManager<T>()` helper method demonstrates a smart pattern: it first checks if a manager already exists in the scene (useful during editor testing) and registers it if found, otherwise creates a new instance. This flexibility supports both runtime initialization and editor-based scene setup workflows.

---

### GameManager

**Location:** `Assets/Scripts/Core/GameManager.cs`

The `GameManager` serves as the universal game state controller, coordinating high-level game functionality including scene management, pause/resume mechanics, and integration with the main menu system. It acts as a facade for common game operations, providing a clean API for other systems to interact with.

#### Key Features:

- **Scene Management**: Provides async/await-based scene loading and unloading through UniTask, with proper event notifications for scene transitions. Supports both single and additive scene loading modes
- **Pause System**: Implements pause/resume functionality through Unity's `Time.timeScale` with corresponding event triggers for UI updates
- **Camera Caching**: Maintains a cached reference to the main camera, avoiding repeated expensive `Camera.main` calls that use `FindGameObjectWithTag` internally
- **Event Integration**: Exposes the EventManager instance and subscribes to relevant input events (Escape, Pause) to trigger appropriate game state changes
- **Main Menu Control**: Delegates main menu visibility to MainMenuManager while coordinating with the event system to notify listeners of menu state changes
- **Current Scene Tracking**: Maintains references to the active scene including name and build index for easy access by other systems

The GameManager demonstrates proper dependency injection patterns - it receives EventManager and MainMenuManager through constructor injection, explicitly declaring its dependencies. It also properly manages the lifecycle of event subscriptions, subscribing in `Start()` and unsubscribing in `OnDestroy()` to prevent memory leaks.

---

### EventManager

**Location:** `Assets/Scripts/Core/EventManager.cs`

The `EventManager` implements a centralized event system using Unity's `UnityEvent` framework, enabling decoupled communication between game systems. Rather than having systems directly reference each other, they communicate through events, making the architecture more modular and testable.

#### Event Categories:

**Input Events:**
- `OnEscapePressed`: Triggered when the Escape key is pressed
- `OnPausePressed`: Triggered when the Pause key is pressed

**Game State Events:**
- `OnGamePaused`: Fired when the game enters paused state
- `OnGameResumed`: Fired when the game exits paused state

**Scene Events:**
- `OnSceneLoadStarted`: Notifies listeners when a scene begins loading (includes scene name)
- `OnSceneLoadCompleted`: Notifies listeners when a scene finishes loading

**Player Events:**
- `OnPlayerHealthChanged`: Broadcasts player health updates (prepared for future implementation)
- `OnPlayerDied`: Signals player death event

**UI Events:**
- `OnMainMenuOpened`: Indicates main menu has been displayed
- `OnMainMenuClosed`: Indicates main menu has been hidden

#### Design Benefits:

The EventManager provides trigger helper methods (e.g., `TriggerEscapePressed()`, `TriggerGamePaused()`) that encapsulate event invocation, making it easy to fire events from anywhere in the codebase. This pattern ensures null-safety through the null-conditional operator (`?.Invoke()`) and provides a single source of truth for all game events. The debug helper `LogActiveListeners()` aids in troubleshooting by reporting listener counts for registered events.

---

### InputManager

**Location:** `Assets/Scripts/Core/InputManager.cs`

The `InputManager` handles all global system-level input using Unity's new Input System package, translating raw keyboard input into high-level events through the EventManager. It focuses exclusively on global inputs (Escape, Pause, system hotkeys) while leaving game-specific inputs (player movement, combat) to dedicated controller classes.

#### Core Functionality:

- **Global Input Polling**: Monitors keyboard input every frame for system-level keys (Escape, Pause, potential settings/debug keys)
- **Event Translation**: Converts raw input into semantic events by triggering corresponding EventManager methods
- **Null-Safety**: Includes proper null checks for keyboard availability, ensuring compatibility with different input configurations
- **Debug Mode**: Provides optional debug logging to trace input events for troubleshooting
- **Utility Methods**: Exposes `IsKeyPressed()` and `IsKeyPressedThisFrame()` helpers for other scripts that need to query input state

#### Architecture Justification:

By separating global inputs from gameplay inputs, the architecture remains clean and focused. The InputManager doesn't need to know about player controllers, enemy AI, or game mechanics - it simply reports when system keys are pressed. This separation of concerns makes the codebase easier to understand and modify. Game-specific input handling can be implemented in player controller classes or action map systems without cluttering this core system.

---

### MainMenuManager

**Location:** `Assets/BugWars/UI/MainMenu/MainMenuManager.cs`

The `MainMenuManager` controls the main menu user interface using Unity's UI Toolkit (formerly UIElements), providing a modern, performant UI system built on retained-mode rendering. It manages menu visibility, button interactions, and integration with the game's event system.

#### Key Components:

- **UI Toolkit Integration**: Uses `UIDocument` component with UXML visual trees for declarative UI definition, separating presentation from logic
- **Element Queries**: Locates UI elements by name using the `Q<T>()` query API (`MainMenuContainer`, `SettingsButton`, `ExitButton`)
- **Event Handling**: Registers button click callbacks and responds to global events (Escape key) to toggle menu visibility
- **Visibility Management**: Controls menu display through `DisplayStyle.Flex` and `DisplayStyle.None`, providing instant show/hide functionality
- **State Tracking**: Maintains `IsMenuVisible` property to allow other systems to query menu state

#### Implementation Details:

The MainMenuManager demonstrates proper component lifecycle management - it waits for VContainer to inject dependencies in `Construct()`, initializes UI elements in `Start()` after the UIDocument is configured, and cleans up event subscriptions in `OnDestroy()`. The `OnExitButtonClicked()` method includes platform-specific quit logic, stopping play mode in the editor and calling `Application.Quit()` in builds.

This component showcases the synergy between VContainer and UI Toolkit - dependencies are injected automatically, while UI elements are queried and configured using UI Toolkit's retained-mode API. The result is clean, testable code that separates concerns between UI presentation and game logic.

---

## Gameplay Systems

### Combat Mechanics

The combat system (currently in development) will feature:
- Multiple weapon types with distinct behavior patterns
- Enemy AI with varying aggression and movement strategies
- Health and damage systems with visual feedback
- Combo mechanics for skilled players
- Environmental hazards and interactive elements

### Progression System

Bug Wars will implement a multi-layered progression system:
- Wave-based difficulty scaling with increasing enemy counts and types
- Resource collection and upgrade paths
- Persistent unlocks across play sessions
- Achievement system tracking player milestones
- Leaderboard integration for competitive players

### Enemy Design

Each bug type will feature unique characteristics:
- **Ants**: Swarm mechanics with coordinated group attacks
- **Spiders**: Web-based area denial and ambush tactics
- **Wasps**: Aerial assault units with ranged stinger attacks
- **Beetles**: Heavily armored tanks requiring strategic weak point targeting
- **Boss Enemies**: Multi-phase encounters with unique mechanics

### Camera System

Bug Wars employs a sophisticated camera system powered by Cinemachine to create dynamic, responsive camera behaviors that enhance gameplay clarity and cinematic presentation. The camera is not just a passive observer but an active participant in the game's feel and player experience.

#### Virtual Camera Setup:

**Main Combat Camera (Priority: 10)**
- **Body**: Framing Transposer - Keeps player character optimally positioned in frame with soft zone dead zones for natural movement
- **Aim**: Composer - Dynamically frames the player and nearby threats, adjusting composition based on combat intensity
- **Extensions**: Collision detection to prevent camera clipping, subtle procedural noise for organic feel
- **Use Case**: Default camera during standard gameplay and combat encounters

**Boss Encounter Camera (Priority: 20)**
- **Body**: Transposer with wider framing offset to show both player and boss simultaneously
- **Aim**: Group Composer - Frames both player and boss within the viewport for dramatic confrontations
- **Extensions**: Impulse listener for impact-based camera shake during boss attacks
- **Activation**: Triggered by EventManager's boss spawn events, automatically takes priority over combat camera

**Death Camera (Priority: 30)**
- **Body**: Hard Lock to player position with slow dolly-out effect
- **Aim**: POV with timed rotation to create dramatic final moments
- **Activation**: Triggered on player death event, highest priority for cinematic presentation

**Cutscene/Scripted Cameras (Priority: 100)**
- **Body & Aim**: Varies per sequence, controlled via Timeline integration
- **Use Case**: Wave completion celebrations, boss introductions, tutorial moments

#### Dynamic Camera Behaviors:

- **Combat Intensity Response**: Camera field of view (FOV) and damping values adjust based on enemy proximity and count - tighter framing during one-on-one encounters, wider framing during swarm situations
- **Impact Feedback**: Cinemachine Impulse System triggers procedural shake on damage events, with magnitude scaled to damage amount
- **Smooth Transitions**: Automatic blending between Virtual Cameras using ease-in-out curves for seamless priority changes
- **Look-Ahead**: Camera anticipates player movement direction, positioning the frame slightly ahead for better visibility
- **Vertical Reframing**: Automatic camera tilt adjustments when facing flying enemies (wasps) or ground-based threats (beetles)

#### Integration with Game Systems:

The camera system integrates with Bug Wars' event-driven architecture through EventManager subscriptions:
- `OnGamePaused` → Reduces camera update rate and locks position
- `OnGameResumed` → Restores normal camera behavior
- `OnPlayerHealthChanged` → Triggers intensity-based FOV changes and trauma shake
- `OnPlayerDied` → Activates death camera sequence
- Boss-related events → Switch to specialized boss camera rigs

Camera state changes can be sequenced with UniTask for precise timing - for example, awaiting a camera blend completion before starting a boss fight introduction or victory celebration. Custom Cinemachine extensions can receive VContainer-injected dependencies to access GameManager state, enabling camera behaviors that respond to game conditions.

---

## Technical Roadmap

<CardGrid stagger>
	<Card title="Physics & Movement" icon="rocket">
		Implement responsive character controller with custom physics tuning for tight, responsive gameplay feel.
	</Card>
	<Card title="Cinemachine Camera System" icon="star">
		Configure Virtual Camera rigs for combat, boss encounters, and cinematic sequences with dynamic blending and procedural behaviors.
	</Card>
	<Card title="AI Behavior Trees" icon="puzzle">
		Develop modular AI system using behavior trees for complex enemy decision-making and state management.
	</Card>
	<Card title="Combat System" icon="swords">
		Create weapon framework with hit detection, damage calculation, and visual effects integration.
	</Card>
	<Card title="Audio System" icon="information">
		Integrate spatial audio with dynamic mixing, music states, and procedural sound effect layers.
	</Card>
	<Card title="Save System" icon="document">
		Implement serialization framework for player progress, settings, and unlockables with cloud backup support.
	</Card>
	<Card title="Performance Optimization" icon="approve-check">
		Profile and optimize rendering, physics, and gameplay systems to target 60 FPS on all supported platforms.
	</Card>
</CardGrid>

---

## Development Guidelines

### Code Standards

- All public methods and classes must include XML documentation comments
- Use explicit access modifiers (never rely on implicit `private`)
- Follow Unity's component lifecycle patterns (Awake, Start, Update, OnDestroy)
- Prefer composition over inheritance for gameplay features
- Use `readonly` and `const` where appropriate to prevent accidental mutations

### Architecture Principles

- **Dependency Injection**: All managers and controllers use VContainer for dependency resolution
- **Event-Driven Communication**: Systems communicate through EventManager rather than direct references
- **Async/Await**: Prefer UniTask over coroutines for asynchronous operations
- **Single Responsibility**: Each class should have one clear, well-defined purpose
- **Testability**: Design with unit testing in mind - dependencies should be mockable

### Version Control

- Branch naming: `feature/description`, `bugfix/issue-number`, `refactor/system-name`
- Commit messages should be descriptive and reference issue numbers
- All code must pass automated tests before merging to main branch
- Unity meta files must be committed with corresponding assets

---

## Resources & References

- [VContainer Documentation](https://vcontainer.hadashia.com/)
- [UniTask Documentation](https://github.com/Cysharp/UniTask)
- [Cinemachine Documentation](https://docs.unity3d.com/Packages/com.unity.cinemachine@latest)
- [Unity UI Toolkit Guide](https://docs.unity3d.com/Manual/UIElements.html)
- [Unity Input System](https://docs.unity3d.com/Packages/com.unity.inputsystem@latest)
- [Unity MCP (Model Context Protocol)](https://github.com/CoplayDev/unity-mcp)

---

*Last Updated: 2025-11-11*
