[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.15.4","content-config-digest","9a95ec2e8398aaca","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"where\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":false,\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null,null,null],\"rehypePlugins\":[null,[null,{\"experimentalHeadingIdCompat\":false}],null,[null,{\"themes\":[\"github-dark-high-contrast\",\"light-plus\"],\"defaultLocale\":\"en\",\"cascadeLayer\":\"starlight.components\",\"styleOverrides\":{\"borderRadius\":\"0.4rem\",\"borderWidth\":\"1px\",\"codePaddingBlock\":\"0.75rem\",\"codePaddingInline\":\"1rem\",\"codeFontFamily\":\"var(--__sl-font-mono)\",\"codeFontSize\":\"var(--sl-text-code)\",\"codeLineHeight\":\"var(--sl-line-height)\",\"uiFontFamily\":\"var(--__sl-font)\",\"textMarkers\":{\"lineDiffIndicatorMarginLeft\":\"0.25rem\",\"defaultChroma\":\"45\",\"backgroundOpacity\":\"60%\"},\"borderColor\":\"var(--fb-code-block-bg-color)\",\"codeBackground\":\"var(--fb-code-block-bg-color)\",\"frames\":{\"shadowColor\":\"var(--sl-shadow-sm)\",\"editorActiveTabIndicatorTopColor\":\"unset\",\"editorActiveTabIndicatorBottomColor\":\"var(--sl-color-gray-3)\",\"editorTabBarBorderBottomColor\":\"var(--fb-code-block-bg-color)\",\"frameBoxShadowCssValue\":\"unset\"}},\"plugins\":[{\"name\":\"Starlight Plugin\",\"hooks\":{}},{\"name\":\"astro-expressive-code\",\"hooks\":{}}],\"frames\":{\"extractFileNameFromCode\":false}}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false},\"prefetch\":{\"prefetchAll\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[{\"codes\":[\"en\"],\"path\":\"en\"},{\"codes\":[\"es\"],\"path\":\"es\"},{\"codes\":[\"ja\"],\"path\":\"ja\"},{\"codes\":[\"ko\"],\"path\":\"ko\"}],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}}}","docs",["Map",11,12,46,47,64,65,82,83,98,99,121,122,137,138,157,158,173,174,184,185,195,196,213,214,224,225,240,241,251,252,262,263,273,274,289,290,300,301],"askama",{"id":11,"data":13,"body":41,"filePath":42,"assetImports":43,"digest":45,"deferredRender":16},{"title":14,"description":15,"editUrl":16,"head":17,"template":18,"hero":19,"sidebar":38,"pagefind":16,"draft":39},"StarYo {{ title }}\n","{{ description }}\n",true,[],"splash",{"tagline":20,"image":21,"actions":24},"Congrats on setting up a new Starlight project!",{"alt":22,"file":23},"","__ASTRO_IMAGE_../../assets/houston.webp",[25,32],{"text":26,"link":27,"variant":28,"icon":29},"Example Guide","/guides/example/","primary",{"type":30,"name":31},"icon","right-arrow",{"text":33,"link":34,"variant":35,"icon":36},"Read the Starlight docs","https://starlight.astro.build","minimal",{"type":30,"name":37},"external",{"hidden":39,"attrs":40},false,{},"import { Card, CardGrid } from '@astrojs/starlight/components';\nimport AskamaProvider from '@/components/providers/AskamaProvider.astro';\n\n\u003CAskamaProvider />","src/content/docs/askama.mdx",[44],"../../assets/houston.webp","a0fe9e0f4b3f6174","index",{"id":46,"data":48,"body":59,"filePath":60,"assetImports":61,"digest":63,"deferredRender":16},{"title":49,"description":50,"editUrl":16,"head":51,"template":18,"hero":52,"sidebar":57,"pagefind":16,"draft":39},"The Bug Wars Are Within Reach\n","Fight everything that mother nature throws at you!\n",[],{"tagline":53,"image":54,"actions":56},"Kill or be killed.",{"alt":22,"file":55},"__ASTRO_IMAGE_../../assets/BugWars.webp",[],{"hidden":39,"attrs":58},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## Welcome to BugWars\n\nBugWars is an intense survival game where you face the relentless forces of nature. Battle through waves of increasingly dangerous insects and creatures in a fight for survival. Every encounter tests your reflexes, strategy, and determination.\n\n## Game Features\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Intense Combat\" icon=\"rocket\">\n\t\tEngage in fast-paced battles against swarms of bugs and hostile creatures. Master the art of survival through superior tactics and quick reflexes.\n\t\u003C/Card>\n\t\u003CCard title=\"Wave-Based Survival\" icon=\"star\">\n\t\tFace increasingly challenging waves of enemies. Each wave brings new threats and requires adaptive strategies to overcome.\n\t\u003C/Card>\n\t\u003CCard title=\"Play in Browser\" icon=\"laptop\">\n\t\tExperience BugWars directly in your browser with our Unity WebGL build. No downloads required - jump straight into the action.\n\t\u003C/Card>\n\t\u003CCard title=\"Immersive Gameplay\" icon=\"sun\">\n\t\tBuilt with Unity, BugWars delivers stunning visuals and smooth gameplay that keeps you on the edge of your seat.\n\t\u003C/Card>\n\u003C/CardGrid>\n\n## About the Game\n\nBugWars throws you into a world where nature's smallest creatures become your biggest threat. Armed with determination and quick thinking, you must survive wave after wave of bug attacks. The question isn't if you'll fall - it's how long you can last.\n\nWill you rise to the challenge, or will you become another victim of the Bug Wars?\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Start Playing\" icon=\"rocket\">\n\t\tReady to test your skills? Head to our [Game Page](/game) to jump into the action.\n\t\u003C/Card>\n\t\u003CCard title=\"Learn More\" icon=\"open-book\">\n\t\tExplore the documentation to learn about game mechanics, strategies, and updates.\n\t\u003C/Card>\n\u003C/CardGrid>","src/content/docs/index.mdx",[62],"../../assets/BugWars.webp","2da3c028e731c7d5","es",{"id":64,"data":66,"body":77,"filePath":78,"assetImports":79,"digest":81,"deferredRender":16},{"title":67,"description":68,"editUrl":16,"head":69,"template":18,"hero":70,"sidebar":75,"pagefind":16,"draft":39},"Las Estrellas Están a Tu Alcance\n","Convierte la inspiración en conexión.\nStarYo te ayuda a descubrir, enviar mensajes y colaborar con los creadores que dan forma al universo de influencia.\n",[],{"tagline":71,"image":72,"actions":74},"La forma más inteligente de alcanzar a los influencers.",{"alt":22,"file":73},"__ASTRO_IMAGE_../../../assets/houston.webp",[],{"hidden":39,"attrs":76},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## Próximos pasos\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Actualizar contenido\" icon=\"pencil\">\n\t\tEdita `src/content/docs/index.mdx` para ver los cambios en esta página.\n\t\u003C/Card>\n\t\u003CCard title=\"Cambiar diseño de página\" icon=\"document\">\n\t\tElimina `template: splash` en `src/content/docs/index.mdx` para mostrar una\n\t\tbarra lateral en esta página.\n\t\u003C/Card>\n\t\u003CCard title=\"Agregar nuevo contenido\" icon=\"add-document\">\n\t\tAgrega archivos Markdown o MDX a `src/content/docs` para crear nuevas páginas.\n\t\u003C/Card>\n\t\u003CCard title=\"Configurar tu sitio\" icon=\"setting\">\n\t\tEdita tu `sidebar` y otras configuraciones en `astro.config.mjs`.\n\t\u003C/Card>\n\t\u003CCard title=\"Leer la documentación\" icon=\"open-book\">\n\t\tAprende más en [la documentación de Starlight](https://starlight.astro.build/).\n\t\u003C/Card>\n\u003C/CardGrid>","src/content/docs/es/index.mdx",[80],"../../../assets/houston.webp","ff4ea634445977e7","ja",{"id":82,"data":84,"body":94,"filePath":95,"assetImports":96,"digest":97,"deferredRender":16},{"title":85,"description":86,"editUrl":16,"head":87,"template":18,"hero":88,"sidebar":92,"pagefind":16,"draft":39},"星は手の届くところに\n","インスピレーションをつながりに変える。\nStarYoは、影響力の世界を形作るクリエイターを発見し、メッセージを送り、コラボレーションするお手伝いをします。\n",[],{"tagline":89,"image":90,"actions":91},"インフルエンサーに到達するスマートな方法。",{"alt":22,"file":73},[],{"hidden":39,"attrs":93},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## 次のステップ\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"コンテンツを更新\" icon=\"pencil\">\n\t\t`src/content/docs/index.mdx`を編集して、このページの変更を確認してください。\n\t\u003C/Card>\n\t\u003CCard title=\"ページレイアウトを変更\" icon=\"document\">\n\t\t`src/content/docs/index.mdx`の`template: splash`を削除すると、\n\t\tこのページにサイドバーが表示されます。\n\t\u003C/Card>\n\t\u003CCard title=\"新しいコンテンツを追加\" icon=\"add-document\">\n\t\t`src/content/docs`にMarkdownまたはMDXファイルを追加して、新しいページを作成します。\n\t\u003C/Card>\n\t\u003CCard title=\"サイトを設定\" icon=\"setting\">\n\t\t`astro.config.mjs`で`sidebar`やその他の設定を編集します。\n\t\u003C/Card>\n\t\u003CCard title=\"ドキュメントを読む\" icon=\"open-book\">\n\t\t詳細は[Starlightドキュメント](https://starlight.astro.build/)をご覧ください。\n\t\u003C/Card>\n\u003C/CardGrid>","src/content/docs/ja/index.mdx",[80],"296fd088565d252a","guides/example",{"id":98,"data":100,"body":106,"filePath":107,"digest":108,"rendered":109},{"title":26,"description":101,"editUrl":16,"head":102,"template":103,"sidebar":104,"pagefind":16,"draft":39},"A guide in my new Starlight docs site.",[],"doc",{"hidden":39,"attrs":105},{},"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps.\nWriting a good guide requires thinking about what your users are trying to do.\n\n## Further reading\n\n- Read [about how-to guides](https://diataxis.fr/how-to-guides/) in the Diátaxis framework","src/content/docs/guides/example.md","45662d56567dd245",{"html":110,"metadata":111},"\u003Cp>Guides lead a user through a specific task they want to accomplish, often with a sequence of steps.\nWriting a good guide requires thinking about what your users are trying to do.\u003C/p>\n\u003Cdiv class=\"sl-heading-wrapper level-h2\">\u003Ch2 id=\"further-reading\">Further reading\u003C/h2>\u003Ca class=\"sl-anchor-link\" href=\"#further-reading\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “Further reading”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>Read \u003Ca href=\"https://diataxis.fr/how-to-guides/\">about how-to guides\u003C/a> in the Diátaxis framework\u003C/li>\n\u003C/ul>",{"headings":112,"localImagePaths":117,"remoteImagePaths":118,"frontmatter":119,"imagePaths":120},[113],{"depth":114,"slug":115,"text":116},2,"further-reading","Further reading",[],[],{"title":26,"description":101},[],"ko",{"id":121,"data":123,"body":133,"filePath":134,"assetImports":135,"digest":136,"deferredRender":16},{"title":124,"description":125,"editUrl":16,"head":126,"template":18,"hero":127,"sidebar":131,"pagefind":16,"draft":39},"별은 손이 닿는 곳에\n","영감을 연결로 바꾸세요.\nStarYo는 영향력의 우주를 형성하는 크리에이터를 발견하고, 메시지를 보내고, 협업할 수 있도록 도와줍니다.\n",[],{"tagline":128,"image":129,"actions":130},"인플루언서에게 다가가는 스마트한 방법.",{"alt":22,"file":73},[],{"hidden":39,"attrs":132},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## 다음 단계\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"콘텐츠 업데이트\" icon=\"pencil\">\n\t\t`src/content/docs/index.mdx`를 편집하여 이 페이지의 변경 사항을 확인하세요.\n\t\u003C/Card>\n\t\u003CCard title=\"페이지 레이아웃 변경\" icon=\"document\">\n\t\t`src/content/docs/index.mdx`에서 `template: splash`를 삭제하면\n\t\t이 페이지에 사이드바가 표시됩니다.\n\t\u003C/Card>\n\t\u003CCard title=\"새 콘텐츠 추가\" icon=\"add-document\">\n\t\t`src/content/docs`에 Markdown 또는 MDX 파일을 추가하여 새 페이지를 만드세요.\n\t\u003C/Card>\n\t\u003CCard title=\"사이트 구성\" icon=\"setting\">\n\t\t`astro.config.mjs`에서 `sidebar` 및 기타 설정을 편집하세요.\n\t\u003C/Card>\n\t\u003CCard title=\"문서 읽기\" icon=\"open-book\">\n\t\t자세한 내용은 [Starlight 문서](https://starlight.astro.build/)를 참조하세요.\n\t\u003C/Card>\n\u003C/CardGrid>","src/content/docs/ko/index.mdx",[80],"a5f62424cd693d5c","reference/example",{"id":137,"data":139,"body":145,"filePath":146,"digest":147,"rendered":148},{"title":140,"description":141,"editUrl":16,"head":142,"template":103,"sidebar":143,"pagefind":16,"draft":39},"Example Reference","A reference page in my new Starlight docs site.",[],{"hidden":39,"attrs":144},{},"Reference pages are ideal for outlining how things work in terse and clear terms.\nLess concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what you're documenting.\n\n## Further reading\n\n- Read [about reference](https://diataxis.fr/reference/) in the Diátaxis framework","src/content/docs/reference/example.md","8addf1dc1ec3c10f",{"html":149,"metadata":150},"\u003Cp>Reference pages are ideal for outlining how things work in terse and clear terms.\nLess concerned with telling a story or addressing a specific use case, they should give a comprehensive outline of what you’re documenting.\u003C/p>\n\u003Cdiv class=\"sl-heading-wrapper level-h2\">\u003Ch2 id=\"further-reading\">Further reading\u003C/h2>\u003Ca class=\"sl-anchor-link\" href=\"#further-reading\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “Further reading”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>Read \u003Ca href=\"https://diataxis.fr/reference/\">about reference\u003C/a> in the Diátaxis framework\u003C/li>\n\u003C/ul>",{"headings":151,"localImagePaths":153,"remoteImagePaths":154,"frontmatter":155,"imagePaths":156},[152],{"depth":114,"slug":115,"text":116},[],[],{"title":140,"description":141},[],"game",{"id":157,"data":159,"body":169,"filePath":170,"assetImports":171,"digest":172,"deferredRender":16},{"title":160,"description":161,"editUrl":16,"head":162,"template":18,"hero":163,"sidebar":167,"pagefind":16,"draft":39},"Play BugWars\n","Experience BugWars in your browser with Unity WebGL\n",[],{"tagline":164,"image":165,"actions":166},"Survive the swarm. Prove your worth.",{"alt":22,"file":55},[],{"hidden":39,"attrs":168},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\nimport AstroUnityGameContainer from '@/components/unity-react/AstroUnityGameContainer.astro';\n\nexport const unityConfig = {\n  loaderUrl: \"/assets/game/Build/WebGL.loader.js\",\n  dataUrl: \"/assets/game/Build/WebGL.data\",\n  frameworkUrl: \"/assets/game/Build/WebGL.framework.js\",\n  codeUrl: \"/assets/game/Build/WebGL.wasm\",\n};\n\n## Play BugWars in Your Browser\n\nGet ready to face the ultimate survival challenge. BugWars runs directly in your browser using Unity WebGL technology - no installation required.\n\n\u003CAstroUnityGameContainer\n  config={unityConfig}\n  className=\"bugwars-unity-container\"\n  canvasId=\"bugwars-canvas\"\n  showFullscreenButton={true}\n  height=\"600px\"\n/>\n\n## Game Controls\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Movement\" icon=\"right-arrow\">\n\t\tUse WASD or Arrow Keys to navigate the battlefield and dodge enemy attacks.\n\t\u003C/Card>\n\t\u003CCard title=\"Combat\" icon=\"rocket\">\n\t\tLeft Click or Space to attack. Time your strikes carefully to maximize damage.\n\t\u003C/Card>\n\t\u003CCard title=\"Special Abilities\" icon=\"star\">\n\t\tPress E or Right Click to activate special abilities when available.\n\t\u003C/Card>\n\t\u003CCard title=\"Pause Menu\" icon=\"setting\">\n\t\tPress ESC to pause the game and access settings or return to the main menu.\n\t\u003C/Card>\n\u003C/CardGrid>\n\n## Game Tips\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Stay Mobile\" icon=\"rocket\">\n\t\tConstant movement is key to survival. Standing still makes you an easy target for swarms.\n\t\u003C/Card>\n\t\u003CCard title=\"Prioritize Threats\" icon=\"warning\">\n\t\tFocus on the most dangerous enemies first. Some bugs deal more damage or move faster than others.\n\t\u003C/Card>\n\t\u003CCard title=\"Manage Resources\" icon=\"star\">\n\t\tUse special abilities wisely. Save them for overwhelming situations or tough boss encounters.\n\t\u003C/Card>\n\t\u003CCard title=\"Learn Patterns\" icon=\"open-book\">\n\t\tEach wave has predictable patterns. Study enemy behavior to anticipate attacks.\n\t\u003C/Card>\n\u003C/CardGrid>\n\n## System Requirements\n\n\u003Cdiv style=\"margin: 2rem 0; padding: 1.5rem; background: rgba(99, 102, 241, 0.05); border-radius: 8px; border-left: 4px solid #6366f1;\">\n\n### Recommended Specifications\n\n- **Browser**: Latest version of Chrome, Firefox, Edge, or Safari\n- **WebGL**: WebGL 2.0 support required\n- **RAM**: 4GB or more recommended\n- **Internet**: Stable broadband connection for initial load\n- **Display**: 1280x720 resolution or higher\n\n### Performance Notes\n\nFor the best experience, close unnecessary browser tabs and ensure hardware acceleration is enabled in your browser settings.\n\n\u003C/div>\n\n## Community & Support\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Report Issues\" icon=\"warning\">\n\t\tFound a bug? Report it on our GitHub issues page to help improve the game.\n\t\u003C/Card>\n\t\u003CCard title=\"Share Strategies\" icon=\"comment\">\n\t\tJoin the community to share your best survival strategies and high scores.\n\t\u003C/Card>\n\t\u003CCard title=\"Stay Updated\" icon=\"information\">\n\t\tFollow development progress and get notified when new features and updates are released.\n\t\u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv style=\"text-align: center; margin-top: 3rem; padding: 2rem; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%); border-radius: 12px;\">\n\t\u003Ch3 style=\"margin-bottom: 0.5rem;\">Ready to Fight?\u003C/h3>\n\t\u003Cp style=\"color: #94a3b8;\">The bugs are waiting. Show them what you're made of.\u003C/p>\n\u003C/div>","src/content/docs/game.mdx",[62],"9f44be97673f7b3d","gdd",{"id":173,"data":175,"body":181,"filePath":182,"digest":183,"deferredRender":16},{"title":176,"description":177,"editUrl":16,"head":178,"template":103,"sidebar":179,"pagefind":16,"draft":39},"Bug Wars - Game Design Document","Comprehensive technical documentation for the Bug Wars Unity game project",[],{"hidden":39,"attrs":180},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Bug Wars - Game Design Document\n\n## Game Overview\n\n**Bug Wars** is a survival action game built in Unity where players face off against relentless waves of insects and creatures from the natural world. \nThe game features intense combat mechanics, strategic resource management, and progressive difficulty scaling.\nPlayers must adapt to different bug types, each with unique behaviors and attack patterns, while managing limited resources and upgrading their defensive capabilities.\n\nThe game is built using modern Unity development practices, leveraging powerful architectural patterns through dependency injection (VContainer) and asynchronous programming (UniTask).\nThe core architecture emphasizes modularity, testability, and clean separation of concerns, making the codebase maintainable and scalable as new features are added.\n\n## Core Technologies\n\n### VContainer - Dependency Injection Framework\n\n[VContainer GitHub Repository](https://github.com/hadashiA/VContainer)\n\nVContainer is the fastest and most lightweight dependency injection (DI) framework for Unity, providing a robust foundation for managing object lifecycles and dependencies throughout Bug Wars.\nUnlike traditional Unity development where components find each other using `FindObjectOfType` or singleton patterns, VContainer enables proper inversion of control (IoC) where dependencies are explicitly declared and automatically injected.\n\nIn Bug Wars, VContainer serves as the backbone of our architecture through the `GameLifetimeScope` class, which orchestrates all core managers (GameManager, EventManager, InputManager, etc.). \nThis approach eliminates tight coupling between systems, makes testing easier through dependency mocking, and provides clear visibility into system dependencies. \nVContainer's constructor and method injection automatically resolves dependencies when components are created, ensuring that all required references are available before a component begins its work.\n\nThe framework's performance characteristics are crucial for games - VContainer generates optimal IL code at build time, resulting in zero reflection overhead at runtime. \nThis makes it ideal for performance-critical game environments where every frame counts. \nOur implementation uses VContainer's `LifetimeScope` to manage singleton managers that persist across scenes, while still maintaining the flexibility to add scoped dependencies for level-specific systems.\n\n### UniTask - High-Performance Async/Await\n\n[UniTask GitHub Repository](https://github.com/Cysharp/UniTask)\n\nUniTask is a zero-allocation async/await framework specifically designed for Unity, replacing Unity's older Coroutine system with modern C# async/await patterns.\nUnlike standard .NET Tasks which allocate garbage on every operation, UniTask is a value-type based implementation that provides true zero-allocation asynchronous programming, making it perfect for game development where garbage collection pauses can cause frame drops.\n\nIn Bug Wars, UniTask powers all asynchronous operations including scene loading, resource streaming, and complex animation sequences.\nThe `GameManager` uses UniTask extensively for scene management, providing clean async/await syntax instead of callback-based coroutines.\nThis makes our code more readable and maintainable - for example, loading a scene with progress tracking becomes a straightforward async method rather than a complex IEnumerator with nested callbacks.\nUniTask also integrates seamlessly with Unity's lifecycle, providing PlayerLoop-based task scheduling that respects Unity's frame timing.\n\nThe performance benefits of UniTask are substantial - it avoids the heap allocations associated with coroutines and standard Tasks, operates faster than Unity's coroutine system, and provides better debugging support through proper stack traces.\nUniTask also includes powerful operators for working with Unity's async operations, time-based delays, and cancellation tokens, giving us fine-grained control over asynchronous workflows.\nThis is particularly important for Bug Wars' gameplay systems where we need responsive, non-blocking operations for enemy spawning, animation blending, and networked events.\n\n### Cinemachine - Procedural Camera System\n\n[Cinemachine Documentation](https://docs.unity3d.com/Packages/com.unity.cinemachine@latest)\n\nCinemachine is Unity's powerful procedural camera system that enables AAA-quality camera behaviors without complex manual scripting.\nInstead of writing custom camera controllers with follow logic, damping, and collision detection, Cinemachine provides a component-based approach where cameras are assembled from modular building blocks called Virtual Cameras.\nThis shifts camera work from programming to design, allowing rapid iteration on camera feel and behavior.\n\nIn Bug Wars, Cinemachine serves as the foundation for all camera systems, providing dynamic camera control that responds to gameplay situations.\nThe framework's Virtual Camera concept allows us to define multiple camera perspectives (combat camera, boss fight camera, death camera) and seamlessly blend between them based on game state.\nEach Virtual Camera can have its own priority, follow target, look-at target, and behavioral components, making it trivial to create context-sensitive camera work that enhances the player experience.\n\n#### Key Features for Bug Wars:\n\n- **Dynamic Follow & Framing**: Cinemachine's Body components (Transposer, Framing Transposer, Orbital Transposer) provide sophisticated player-following logic with customizable damping, dead zones, and screen composition rules.\nThis ensures the player character stays optimally framed even during intense combat sequences.\n\n- **Smart Aim Handling**: The Aim components manage where the camera looks, supporting hard look-at, composer-based framing, POV rotation, and more. For Bug Wars' combat scenarios, this allows the camera to intelligently frame both the player and approaching enemy threats.\n\n- **Procedural Noise & Shake**: The CinemachineBasicMultiChannelPerlin component enables realistic camera shake for impacts, explosions, and damage feedback. Unlike manual shake implementations, Cinemachine's procedural noise is based on Perlin noise profiles, providing organic, non-repetitive camera movement that can be tuned with frequency and amplitude curves.\n\n- **Collision Detection**: Cinemachine's Collider extension automatically handles camera collision with environment geometry, preventing the camera from clipping through walls or obstacles. This is crucial for Bug Wars' varied combat arenas where maintaining visibility is essential.\n\n- **State-Driven Cameras**: Integration with Unity's Timeline and animation system allows camera cuts and blends to be choreographed alongside gameplay events. Boss introductions, player death sequences, and victory celebrations can all leverage cinematic camera work.\n\n- **Input-Responsive Systems**: Cinemachine's input axes support player-controlled camera rotation, zoom, and positioning, enabling features like manual camera control during strategic moments or targeting specific enemies.\n\n#### Performance & Architecture Benefits:\n\nCinemachine is designed for zero-garbage-collection camera updates, running all calculations on the same frame timeline as Unity's camera system. The framework uses a priority-based blending system where multiple Virtual Cameras can coexist, with the highest-priority camera taking control. Transitions between cameras use sophisticated blending algorithms that can interpolate position, rotation, and lens properties over time, creating smooth cinematic transitions without writing custom interpolation code.\n\nFor Bug Wars' architecture, Cinemachine integrates seamlessly with our existing VContainer and UniTask infrastructure. Virtual Cameras can be activated/deactivated in response to EventManager triggers (player death, boss spawn, wave completion), and camera transitions can be awaited using UniTask for precise sequencing. The component-based design also supports dependency injection - custom Cinemachine extensions can receive injected dependencies for accessing game state when making camera decisions.\n\nThe separation between Virtual Cameras (what you want to shoot) and the Brain (how to execute the shot) provides excellent testability and designer iteration. Camera behaviors can be tuned in the editor without code changes, and multiple camera setups can be A/B tested simply by adjusting priorities. This design philosophy aligns perfectly with Bug Wars' emphasis on clean architecture and rapid iteration.\n\n## AI-Assisted Development with MCP\n\nBug Wars embraces modern AI-assisted development workflows through the Model Context Protocol (MCP), enabling seamless collaboration between human developers and AI assistants directly within the Unity environment. MCP provides a standardized interface for AI tools to interact with development environments, allowing for intelligent code suggestions, automated refactoring, asset management, and context-aware assistance throughout the development process.\n\nBy integrating MCP into our development workflow, we accelerate iteration speed, reduce repetitive tasks, and enable developers to focus on creative problem-solving and game design rather than boilerplate code generation. AI assistants can understand the project's architecture, suggest improvements aligned with our coding standards, and help maintain consistency across the codebase. This is particularly valuable for Bug Wars' complex systems involving VContainer dependency graphs, UniTask async patterns, and Cinemachine configurations.\n\n### Unity MCP - AI Bridge for Unity Editor\n\n[Unity MCP GitHub Repository](https://github.com/CoplayDev/unity-mcp)\n\nUnity MCP is an open-source bridge that connects AI assistants (such as Claude, Cursor, and other LLM-powered tools) directly to the Unity Editor through the Model Context Protocol. This integration enables natural language control of Unity projects, allowing developers to leverage AI for automating workflows, managing assets, and accelerating game development tasks that would traditionally require manual editor interactions.\n\n#### Architecture & Components:\n\nUnity MCP consists of two complementary components that work together:\n\n- **Unity Package**: Installed directly into your Unity project via Package Manager, this component exposes Unity Editor APIs and provides hooks into the project's scene hierarchy, asset database, and editor state.\n- **Python Server**: A local server that runs alongside your development environment, facilitating bidirectional communication between your AI client and the Unity Editor. The server translates natural language commands into Unity API calls and returns structured responses.\n\n#### Key Capabilities for Bug Wars Development:\n\n**Asset Management**\n- Import, create, modify, and delete project resources through AI commands\n- Organize prefabs, scripts, textures, and audio files based on natural language instructions\n- Automate batch asset operations (renaming conventions, folder restructuring, metadata tagging)\n\n**Scene Manipulation**\n- Load, save, and modify scene hierarchies conversationally\n- Create and configure GameObjects with specific components and settings\n- Adjust scene lighting, camera positions, and environment properties without manual editor navigation\n\n**Script Creation & Editing**\n- Generate C# scripts with proper namespace conventions and dependency patterns\n- Modify existing code with AI-suggested improvements and refactoring\n- Validate script syntax and integration with Unity's component system\n\n**Workflow Automation**\n- Execute repetitive Unity Editor tasks through natural language commands\n- Automate testing sequences, build configurations, and deployment steps\n- Query editor state to understand current selections, active windows, and project settings\n\n#### Integration with Bug Wars Workflow:\n\nUnity MCP enhances Bug Wars development by enabling AI assistants to:\n\n- **Understand Architecture Context**: AI can analyze the VContainer dependency graphs and suggest proper injection patterns for new managers and controllers\n- **Generate Cinemachine Configurations**: Describe desired camera behaviors in natural language and have the AI configure Virtual Camera components with appropriate settings\n- **Create Event-Driven Code**: AI understands the EventManager pattern and can generate new events with proper trigger methods and listener subscriptions\n- **Validate Unity Best Practices**: AI can review code for Unity-specific anti-patterns (improper lifecycle usage, expensive operations in Update loops, missing null checks) and suggest corrections\n\n#### Setup Requirements:\n\nFor developers joining the Bug Wars project, Unity MCP setup involves:\n\n1. Install the Unity package via Package Manager (Git URL or local package)\n2. Configure the Python server with your AI client credentials\n3. Ensure Python 3.8+ is installed with required dependencies\n4. Launch the server alongside Unity Editor for active AI assistance\n\nThe system supports multiple simultaneous Unity instances and integrates seamlessly with popular AI coding clients, requiring minimal configuration beyond initial setup. For Bug Wars contributors, Unity MCP accelerates onboarding by allowing new developers to query the AI about architecture decisions, quickly generate boilerplate code following project conventions, and receive context-aware assistance when implementing new gameplay systems.\n\n### Context7 - Up-to-Date Documentation for LLMs\n\n[Context7 Unity Documentation](https://context7.com?q=unity)\n\nContext7 is an open-source Model Context Protocol (MCP) server that provides AI assistants with up-to-date, version-specific documentation and code examples directly from the source. Unlike static documentation or LLM training data that may be outdated, Context7 dynamically retrieves the latest official documentation, ensuring AI-generated code and suggestions align with current best practices and API specifications.\n\n#### What Context7 Provides:\n\nContext7 acts as a real-time documentation bridge between AI assistants and official framework documentation. When an AI needs to reference Unity APIs, component behaviors, or implementation patterns, Context7 fetches the most recent documentation from Unity's official sources and injects it directly into the AI's context. This ensures that code suggestions, API usage examples, and architectural recommendations reflect the latest Unity version being used in the project.\n\n#### Key Benefits for Bug Wars Development:\n\n**Version-Specific Accuracy**\n- Ensures AI suggestions match the exact Unity version used by Bug Wars (avoiding deprecated APIs or unavailable features)\n- Provides accurate documentation for VContainer, UniTask, Cinemachine, and other third-party packages\n- Reduces errors caused by outdated LLM training data or generic code examples\n\n**Enhanced Code Generation**\n- AI assistants can generate Unity scripts with current API signatures and recommended patterns\n- Code examples pulled from official docs ensure compliance with Unity's latest coding standards\n- Reduces manual documentation lookup, allowing developers to stay in flow state\n\n**Contextual API Understanding**\n- When working with complex Unity systems (physics, rendering, UI Toolkit), AI has access to detailed parameter descriptions and usage notes\n- Enables AI to suggest proper component configurations and editor settings\n- Helps AI understand nuances of Unity's component lifecycle and execution order\n\n**Integration with Existing Tools**\n- Works seamlessly with Cursor, Claude, and other AI coding assistants\n- Can be combined with Unity MCP for comprehensive AI-assisted Unity development\n- Requires minimal setup - typically just installing the MCP server and configuring your AI client\n\n#### Use Cases in Bug Wars Workflow:\n\nFor Bug Wars contributors, Context7 enhances AI assistance in several ways:\n\n- **Learning New Systems**: When implementing new Unity features (e.g., Timeline, Shader Graph), AI can reference the latest documentation to guide developers through setup\n- **API Migration**: If Unity versions are updated, Context7 ensures AI suggestions reflect migration paths and new API patterns\n- **Third-Party Package Support**: Context7 can retrieve documentation for VContainer, UniTask, and Cinemachine, helping AI understand our core technology stack\n- **Debugging Assistance**: AI can reference official docs when troubleshooting Unity-specific issues, providing more accurate diagnostic suggestions\n- **Code Review**: AI reviewers can validate that code follows current Unity best practices and uses APIs correctly\n\n#### Setup for Bug Wars Contributors:\n\n1. Install Context7 MCP server from the [official repository](https://github.com/upstash/context7)\n2. Configure your AI client (Claude Desktop, Cursor, etc.) to use the Context7 MCP server\n3. Query Unity-specific documentation using the Unity parameter: `https://context7.com?q=unity`\n4. Combine with Unity MCP for a complete AI-assisted development environment\n\nContext7 significantly reduces the friction of working with Unity's extensive API surface, allowing both experienced developers and new contributors to leverage accurate, up-to-date documentation without leaving their development environment.\n\n---\n\n## Core Architecture\n\n### GameLifetimeScope\n\n**Location:** `Assets/Scripts/Core/GameLifetimeScope.cs`\n\nThe `GameLifetimeScope` is the central orchestrator for Bug Wars' dependency injection container, extending VContainer's `LifetimeScope` base class. This class is responsible for bootstrapping the entire game architecture by registering all core managers in their correct dependency order and ensuring they persist across scene transitions.\n\n#### Key Responsibilities:\n\n- **Dependency Registration**: Manages the registration of all singleton managers with the VContainer container, including:\n  - **Core Systems**: EventManager, InputManager, GameManager\n  - **UI Systems**: MainMenuManager\n  - **Rendering Systems**: CameraManager (Cinemachine integration)\n  - **World Systems**: TerrainManager (procedural generation)\n  - **Gameplay Systems**: EntityManager (entity tracking and queries)\n- **Initialization Order**: Ensures components are registered in proper dependency order:\n  1. **EventManager** (no dependencies) - foundational event system\n  2. **InputManager** (depends on EventManager) - input event translation\n  3. **MainMenuManager** (depends on EventManager) - UI system\n  4. **CameraManager** (no dependencies) - camera control and frustum culling\n  5. **TerrainManager** (depends on CameraManager) - terrain generation with culling\n  6. **EntityManager** (no dependencies) - entity registry\n  7. **GameManager** (depends on all above) - high-level game coordination\n- **Singleton Pattern Enforcement**: Implements singleton pattern with DontDestroyOnLoad, ensuring only one GameLifetimeScope exists across scene transitions\n- **Auto-Manager Creation**: Intelligently creates missing managers at runtime if not assigned in Inspector, supporting both editor-based and code-driven workflows\n- **UI Configuration**: Handles the creation and configuration of UIDocument-based interfaces, including PanelSettings and VisualTreeAssets for the main menu system\n- **Runtime PanelSettings**: Intelligently creates default PanelSettings at runtime if none are assigned, ensuring UI rendering works correctly even without manual configuration\n- **Lifecycle Management**: Marks core managers with `DontDestroyOnLoad()` to persist across scene transitions, maintaining game state throughout the player's session\n\n**Async Initialization:**\n\nThe GameLifetimeScope supports async manager initialization through VContainer's `IStartable` interface. TerrainManager, for example, implements async initialization to generate the initial terrain chunks without blocking the main thread, ensuring smooth game startup.\n\nThe `RegisterOrCreateManager\u003CT>()` helper method demonstrates a smart pattern: it first checks if a manager already exists in the scene (useful during editor testing) and registers it if found, otherwise creates a new instance. This flexibility supports both runtime initialization and editor-based scene setup workflows.\n\n---\n\n### GameManager\n\n**Location:** `Assets/Scripts/Core/GameManager.cs`\n\nThe `GameManager` serves as the universal game state controller, coordinating high-level game functionality including scene management, pause/resume mechanics, and integration with the main menu system. It acts as a facade for common game operations, providing a clean API for other systems to interact with.\n\n#### Key Features:\n\n- **Scene Management**: Provides async/await-based scene loading and unloading through UniTask, with proper event notifications for scene transitions. Supports both single and additive scene loading modes\n- **Pause System**: Implements pause/resume functionality through Unity's `Time.timeScale` with corresponding event triggers for UI updates\n- **Camera Caching**: Maintains a cached reference to the main camera, avoiding repeated expensive `Camera.main` calls that use `FindGameObjectWithTag` internally\n- **Event Integration**: Exposes the EventManager instance and subscribes to relevant input events (Escape, Pause) to trigger appropriate game state changes\n- **Main Menu Control**: Delegates main menu visibility to MainMenuManager while coordinating with the event system to notify listeners of menu state changes\n- **Current Scene Tracking**: Maintains references to the active scene including name and build index for easy access by other systems\n\nThe GameManager demonstrates proper dependency injection patterns - it receives EventManager and MainMenuManager through constructor injection, explicitly declaring its dependencies. It also properly manages the lifecycle of event subscriptions, subscribing in `Start()` and unsubscribing in `OnDestroy()` to prevent memory leaks.\n\n---\n\n### EventManager\n\n**Location:** `Assets/Scripts/Core/EventManager.cs`\n\nThe `EventManager` implements a centralized event system using Unity's `UnityEvent` framework, enabling decoupled communication between game systems. Rather than having systems directly reference each other, they communicate through events, making the architecture more modular and testable.\n\n#### Event Categories:\n\n**Input Events:**\n- `OnEscapePressed`: Triggered when the Escape key is pressed\n- `OnPausePressed`: Triggered when the Pause key is pressed\n\n**Game State Events:**\n- `OnGamePaused`: Fired when the game enters paused state\n- `OnGameResumed`: Fired when the game exits paused state\n\n**Scene Events:**\n- `OnSceneLoadStarted`: Notifies listeners when a scene begins loading (includes scene name)\n- `OnSceneLoadCompleted`: Notifies listeners when a scene finishes loading\n\n**Player Events:**\n- `OnPlayerHealthChanged`: Broadcasts player health updates (prepared for future implementation)\n- `OnPlayerDied`: Signals player death event\n\n**UI Events:**\n- `OnMainMenuOpened`: Indicates main menu has been displayed\n- `OnMainMenuClosed`: Indicates main menu has been hidden\n\n#### Design Benefits:\n\nThe EventManager provides trigger helper methods (e.g., `TriggerEscapePressed()`, `TriggerGamePaused()`) that encapsulate event invocation, making it easy to fire events from anywhere in the codebase. This pattern ensures null-safety through the null-conditional operator (`?.Invoke()`) and provides a single source of truth for all game events. The debug helper `LogActiveListeners()` aids in troubleshooting by reporting listener counts for registered events.\n\n---\n\n### InputManager\n\n**Location:** `Assets/Scripts/Core/InputManager.cs`\n\nThe `InputManager` handles all global system-level input using Unity's new Input System package, translating raw keyboard input into high-level events through the EventManager. It focuses exclusively on global inputs (Escape, Pause, system hotkeys) while leaving game-specific inputs (player movement, combat) to dedicated controller classes.\n\n#### Core Functionality:\n\n- **Global Input Polling**: Monitors keyboard input every frame for system-level keys (Escape, Pause, potential settings/debug keys)\n- **Event Translation**: Converts raw input into semantic events by triggering corresponding EventManager methods\n- **Null-Safety**: Includes proper null checks for keyboard availability, ensuring compatibility with different input configurations\n- **Debug Mode**: Provides optional debug logging to trace input events for troubleshooting\n- **Utility Methods**: Exposes `IsKeyPressed()` and `IsKeyPressedThisFrame()` helpers for other scripts that need to query input state\n\n#### Architecture Justification:\n\nBy separating global inputs from gameplay inputs, the architecture remains clean and focused. The InputManager doesn't need to know about player controllers, enemy AI, or game mechanics - it simply reports when system keys are pressed. This separation of concerns makes the codebase easier to understand and modify. Game-specific input handling can be implemented in player controller classes or action map systems without cluttering this core system.\n\n---\n\n### MainMenuManager\n\n**Location:** `Assets/BugWars/UI/MainMenu/MainMenuManager.cs`\n\nThe `MainMenuManager` controls the main menu user interface using Unity's UI Toolkit (formerly UIElements), providing a modern, performant UI system built on retained-mode rendering. It manages menu visibility, button interactions, and integration with the game's event system.\n\n#### Key Components:\n\n- **UI Toolkit Integration**: Uses `UIDocument` component with UXML visual trees for declarative UI definition, separating presentation from logic\n- **Element Queries**: Locates UI elements by name using the `Q\u003CT>()` query API (`MainMenuContainer`, `SettingsButton`, `ExitButton`)\n- **Event Handling**: Registers button click callbacks and responds to global events (Escape key) to toggle menu visibility\n- **Visibility Management**: Controls menu display through `DisplayStyle.Flex` and `DisplayStyle.None`, providing instant show/hide functionality\n- **State Tracking**: Maintains `IsMenuVisible` property to allow other systems to query menu state\n\n#### Implementation Details:\n\nThe MainMenuManager demonstrates proper component lifecycle management - it waits for VContainer to inject dependencies in `Construct()`, initializes UI elements in `Start()` after the UIDocument is configured, and cleans up event subscriptions in `OnDestroy()`. The `OnExitButtonClicked()` method includes platform-specific quit logic, stopping play mode in the editor and calling `Application.Quit()` in builds.\n\nThis component showcases the synergy between VContainer and UI Toolkit - dependencies are injected automatically, while UI elements are queried and configured using UI Toolkit's retained-mode API. The result is clean, testable code that separates concerns between UI presentation and game logic.\n\n---\n\n## Gameplay Systems\n\n### Terrain Generation System\n\n**Location:** `Assets/Scripts/Terrain/`\n\nBug Wars features a sophisticated procedural terrain generation system built on a chunk-based streaming architecture, providing infinite explorable worlds with optimal performance through intelligent culling and asynchronous loading.\n\n#### TerrainManager\n\n**Location:** `Assets/Scripts/Terrain/TerrainManager.cs`\n\nThe `TerrainManager` orchestrates the entire terrain generation pipeline, managing chunk lifecycle from creation through rendering to eventual unloading based on player position and camera visibility.\n\n**Key Features:**\n\n- **Chunk-Based Streaming Architecture**: Generates terrain in discrete chunks (80x80 units each) arranged in a dynamic grid around the player, allowing for theoretically infinite world exploration without performance degradation\n- **Perlin Noise Procedural Generation**: Uses configurable seed values for deterministic terrain generation, ensuring the same seed always produces identical terrain layouts (useful for testing and potential multiplayer synchronization)\n- **Async Loading with UniTask**: All terrain generation operations execute asynchronously on background threads, preventing frame hitches and maintaining smooth 60 FPS gameplay even during chunk generation\n- **Frustum Culling Integration**: Works closely with CameraManager to automatically hide chunks outside the camera's view frustum, dramatically reducing draw calls and improving rendering performance\n- **Dynamic Chunk Distance Management**:\n  - Loads chunks within 2-chunk radius of player position (proactive loading)\n  - Unloads chunks beyond 3-chunk radius (memory management)\n  - Configurable distances for performance tuning on different hardware\n\n**Technical Implementation Details:**\n\n- **Chunk Resolution**: 20 vertices per side, creating a low-poly aesthetic that's both performant and stylistically distinctive\n- **Chunk Size**: 80x80 units (quadrupled from original 20x20 for better performance/detail balance)\n- **Height Multiplier**: 3x default elevation for dramatic terrain variation\n- **Update Frequency**: Configurable culling checks (0.5s default) to balance responsiveness with CPU overhead\n- **Parallel Generation**: Uses `UniTask.WhenAll()` for parallel chunk generation, significantly reducing initial world load time\n\n**Performance Optimizations:**\n\nThe TerrainManager implements several critical optimizations:\n- Background thread mesh generation prevents main thread blocking\n- Cached frustum planes enable batch culling operations without per-chunk camera queries\n- Spatial hashing for efficient chunk lookup by world position\n- Deferred mesh application (generation on worker thread, Unity mesh assignment on main thread)\n\n**Integration Points:**\n\n- **VContainer Registration**: Registered as singleton in GameLifetimeScope with `IStartable` interface for automatic initialization\n- **CameraManager Dependency**: Receives CameraManager via constructor injection for frustum culling operations\n- **EventManager Integration**: Can trigger events for terrain generation completion, chunk loading progress\n\n#### TerrainChunk\n\n**Location:** `Assets/Scripts/Terrain/TerrainChunk.cs`\n\nIndividual terrain chunk responsible for mesh generation, physics collision, and visibility management.\n\n**Core Functionality:**\n\n- **Procedural Mesh Generation**: Uses 2D Perlin noise to generate natural-looking heightmaps with configurable parameters:\n  - Noise scale for feature size control\n  - Height multiplier for elevation range\n  - Seed offset for deterministic generation\n- **Async Mesh Construction**: Entire mesh generation process (vertex calculation, UV mapping, triangle indexing) runs on ThreadPool threads\n- **Automatic Physics Colliders**: Each chunk includes a `MeshCollider` component for terrain collision detection, enabling gameplay interactions with terrain\n- **Visibility Control**: Implements `Show()`/`Hide()` methods for frustum culling, disabling MeshRenderer without destroying the chunk object\n\n**Mesh Generation Pipeline:**\n\n1. **Vertex Generation**: Calculate vertex positions using Perlin noise sampling offset by world position\n2. **UV Mapping**: Generate texture coordinates for future terrain texturing support\n3. **Triangle Construction**: Build triangle indices following Unity's winding order conventions\n4. **Normal Calculation**: Automatically recalculate normals for proper lighting interaction\n5. **Collider Assignment**: Apply generated mesh to MeshCollider for physics interactions\n\n**Memory Management:**\n\nTerrainChunk implements proper cleanup in `OnDestroy()`, ensuring mesh memory is properly released when chunks are unloaded. This prevents memory leaks during extended gameplay sessions.\n\n---\n\n### Sprite Rendering System\n\n**Location:** `Assets/BugWars/Prefabs/Character/Samurai/`\n\nBug Wars implements a high-performance 2D sprite rendering system in a 3D environment using a custom URP shader with GPU-based billboarding, mesh-based rendering, and frame-based animation driven by JSON sprite atlases.\n\n#### Architecture Overview\n\nThe sprite rendering system replaces Unity's traditional SpriteRenderer component with a MeshRenderer + custom shader approach, providing:\n- **GPU-based billboarding** (no CPU transform updates)\n- **Frame-based animation** via shader UV remapping\n- **MaterialPropertyBlock** for per-instance parameters without material duplication\n- **Zero-garbage animation updates** using cached shader property IDs\n\nThis approach is significantly more performant than traditional billboard systems that update transforms in `LateUpdate()`, as all rotation calculations happen on the GPU within the vertex shader.\n\n#### SamuraiAnimatedSprite_Unity6 Shader\n\n**Location:** `Assets/BugWars/Prefabs/Character/Samurai/SamuraiAnimatedSprite_Unity6.shader`\n\nCustom URP-compatible shader implementing GPU-based billboarding with sprite sheet animation support.\n\n**Shader Features:**\n\n- **Billboard Modes**:\n  - `Mode 0`: No billboarding (standard object transform)\n  - `Mode 1`: Cylindrical billboarding (Y-axis locked, ideal for ground-based characters)\n  - `Mode 2`: Spherical billboarding (full camera facing)\n- **Frame Animation**: UV remapping via `_FrameUVMin` and `_FrameUVMax` shader properties for sprite atlas animation\n- **Sprite Flipping**: `_FlipX` and `_FlipY` parameters for directional character facing without mesh regeneration\n- **Transparency**: Alpha cutoff with configurable threshold for sprite edge handling\n- **URP Integration**: Proper fog support, UniversalForward rendering, transparent queue\n\n**Technical Implementation:**\n\nThe shader's vertex function calculates billboard rotation by constructing world-space quad positions from camera basis vectors:\n- Cylindrical mode: Projects camera direction onto XZ plane, builds right vector perpendicular to world up\n- Spherical mode: Uses camera's inverse view matrix to extract right/up vectors directly\n- UV coordinates are remapped to frame bounds and optionally flipped based on shader parameters\n\n**Performance Benefits:**\n- Billboard rotation executes entirely on GPU (no CPU `LateUpdate()` overhead)\n- Batching-friendly: multiple characters can share the same material with per-instance property blocks\n- Zero-allocation updates: MaterialPropertyBlock reuse eliminates GC pressure\n\n#### Sprite Atlas System\n\n**Location:** `Assets/BugWars/Prefabs/Character/Samurai/SpriteAtlasData.cs`\n\nJSON-driven sprite atlas format for defining animation frames and sequences.\n\n**Atlas Structure:**\n\n```json\n{\n  \"meta\": {\n    \"version\": \"1.0\",\n    \"size\": { \"w\": 1024, \"h\": 1024 },\n    \"frameSize\": 128,\n    \"frameCount\": 60\n  },\n  \"frames\": {\n    \"Idle_0\": {\n      \"x\": 0, \"y\": 0, \"w\": 128, \"h\": 128,\n      \"animation\": \"Idle\",\n      \"index\": 0,\n      \"uv\": {\n        \"min\": { \"x\": 0.0, \"y\": 0.875 },\n        \"max\": { \"x\": 0.125, \"y\": 1.0 }\n      }\n    }\n  },\n  \"animations\": {\n    \"Idle\": {\n      \"frames\": [\"Idle_0\", \"Idle_1\", \"Idle_2\", \"Idle_3\"],\n      \"frameCount\": 4,\n      \"fps\": 8\n    }\n  }\n}\n```\n\n**Key Components:**\n\n- **Meta**: Atlas metadata (size, frame dimensions, total frame count)\n- **Frames**: Dictionary mapping frame names to UV coordinates, positions, and animation membership\n- **Animations**: Sequences of frame names with playback speed (FPS)\n- **UV Coordinates**: Precomputed normalized UV bounds for direct shader usage\n\n**Data Classes:**\n\n- `SpriteAtlasData`: Root container with Newtonsoft.Json deserialization\n- `FrameData`: Individual frame definition with pixel coordinates and UV bounds\n- `AnimationData`: Frame sequence with FPS and calculated frame duration\n- Uses Newtonsoft.Json for robust dictionary parsing (Unity's JsonUtility doesn't support dictionaries)\n\n#### Samurai Character Implementation\n\n**Location:** `Assets/BugWars/Prefabs/Character/Samurai/Samurai.cs`\n\nThe Samurai class demonstrates the sprite rendering system's practical implementation, serving as the player character and reference implementation for future entities.\n\n**Rendering Pipeline:**\n\n1. **Component Replacement**:\n   - At runtime, removes `SpriteRenderer` component (incompatible with custom materials)\n   - Adds `MeshFilter` with procedurally-generated quad mesh (1x1 unit, centered)\n   - Adds `MeshRenderer` with assigned SamuraiMaterial (uses custom shader)\n\n2. **Animation State Mapping**:\n   - Maps universal `EntityAnimationState` enum to Samurai-specific animation names\n   - Example: `EntityAnimationState.Walk` → `\"Walk\"` animation in SamuraiAtlas.json\n   - Provides consistent interface across different entity types while allowing character-specific animations\n\n3. **Frame-Based Animation**:\n   - Updates current frame index based on elapsed time and animation FPS\n   - Retrieves UV coordinates from atlas for current frame\n   - Updates shader parameters via MaterialPropertyBlock:\n     - `_FrameUVMin`: Frame's minimum UV coordinates\n     - `_FrameUVMax`: Frame's maximum UV coordinates\n   - No mesh regeneration required—shader handles UV remapping\n\n**Quad Mesh Generation:**\n\n```csharp\n// 1x1 unit quad centered at origin with full UV mapping\nVector3[] vertices = {\n    new Vector3(-0.5f, -0.5f, 0),  // Bottom-left\n    new Vector3( 0.5f, -0.5f, 0),  // Bottom-right\n    new Vector3(-0.5f,  0.5f, 0),  // Top-left\n    new Vector3( 0.5f,  0.5f, 0)   // Top-right\n};\nVector2[] uvs = { (0,0), (1,0), (0,1), (1,1) };\n```\n\nThe shader remaps these 0-1 UV coordinates to the actual frame bounds, allowing a single static mesh to display all animation frames.\n\n**Performance Optimizations:**\n\n- **Cached Shader Property IDs**: `Shader.PropertyToID()` called once in static fields\n- **MaterialPropertyBlock Reuse**: Single property block updated and reused every frame\n- **Billboard Disabled in Entity**: Sets `enableBillboard = false` since shader handles rotation\n- **Async Atlas Loading**: JSON parsing happens during initialization without blocking\n\n**Available Animations:**\n\nThe Samurai includes a comprehensive animation set mapped to universal entity states:\n- `Idle`, `Walk`, `Run`, `Jump`\n- `Attack_1`, `Attack_2`, `Attack_3`\n- `Hurt`, `Dead`, `Shield`\n\nEach animation has configurable FPS in the atlas JSON, allowing independent playback speeds for different actions (e.g., fast attack animations, slow idle breathing).\n\n#### Integration with Entity System\n\nThe sprite rendering system integrates seamlessly with the Entity base class through several mechanisms:\n\n**MaterialPropertyBlock Sharing:**\n\nThe Entity class provides `GetSpritePropertyBlock()` and `ApplySpritePropertyBlock()` helper methods, allowing derived classes like Samurai to extend the property block with additional shader parameters (frame UVs) while preserving Entity's flip state.\n\n**Sprite Flipping:**\n\nEntity's `SetSpriteFlip(bool flipX, bool flipY)` method updates shader parameters that the custom shader reads, enabling camera-relative directional flipping without mesh modifications. The Samurai shader includes `_FlipX` and `_FlipY` parameters that Entity controls based on movement direction.\n\n**Billboard Compatibility:**\n\nWhile Entity includes CPU-based billboarding via `ApplyBillboard()`, characters using the custom shader disable this (`enableBillboard = false`) since GPU-based billboarding is superior. Entity's billboard system remains for entities using traditional rendering.\n\n**Animation State Abstraction:**\n\nEntity defines a universal `EntityAnimationState` enum with states like `Idle`, `Walk`, `Attack_1`, etc. Derived classes override `OnAnimationStateChanged()` to map these universal states to character-specific animation names in their atlas. This enables polymorphic animation control—calling `entity.SetAnimationState(EntityAnimationState.Walk)` works on any entity type.\n\n---\n\n### Entity System\n\n**Location:** `Assets/Scripts/Entity/`\n\nBug Wars implements a unified entity system providing a common foundation for all game actors (players, enemies, NPCs) with shared functionality for health, movement, and visual representation.\n\n#### Entity (Base Class)\n\n**Location:** `Assets/Scripts/Entity/Entity.cs`\n\nAbstract base class defining core functionality shared across all game entities.\n\n**Key Features:**\n\n- **Sprite Rendering Support**: Provides infrastructure for 2D sprite rendering in a 3D environment with both CPU-based and GPU-based (shader) billboard systems\n- **Animation State System**: Universal `EntityAnimationState` enum with states mappable to character-specific animations (Idle, Walk, Run, Jump, Attack variants, Hurt, Dead, Shield)\n- **Sprite Flipping**: Camera-relative sprite flipping via MaterialPropertyBlock and shader parameters (`_FlipX`, `_FlipY`)\n- **Health Management**: Built-in health system with `TakeDamage()`, `Heal()`, and `Die()` methods, with virtual methods allowing subclasses to customize behavior\n- **Physics-Based Movement**: Integrates with Unity's Rigidbody system for realistic movement with gravity and collision detection\n- **Auto-Registration**: Entities automatically register themselves with EntityManager on initialization for centralized tracking\n\n**Technical Implementation:**\n\n- **Component Requirements**: Uses `RequireComponent` attributes to ensure Rigidbody and CapsuleCollider are present\n- **Configurable Properties**:\n  - Movement speed and rotation speed for gameplay tuning\n  - Sprite offset for proper visual positioning relative to collision capsule\n  - Max health configuration for difficulty balancing\n  - Billboard mode toggle (enable for CPU-based, disable for shader-based)\n  - Auto-flip sprite based on movement direction\n- **Billboard Orientation**: CPU-based billboard updates in `LateUpdate()` to rotate sprites toward camera after all movement is complete (used for entities without custom shaders)\n- **MaterialPropertyBlock System**: Maintains a shared property block for sprite shader parameters, allowing derived classes to add custom properties (e.g., frame UVs for animation) while preserving base properties (e.g., flip state)\n\n**Animation State System:**\n\nEntities use a two-tier animation system:\n1. **Universal States**: High-level states defined in `EntityAnimationState` enum\n2. **Character-Specific Mappings**: Derived classes override `OnAnimationStateChanged()` to map universal states to their specific animation names\n\nThis abstraction allows gameplay code to call `entity.SetAnimationState(EntityAnimationState.Attack_1)` without knowing the entity's specific animation implementation.\n\n**Sprite Flipping System:**\n\nThe Entity class provides automatic camera-relative sprite flipping:\n- Movement direction is projected onto the camera's right vector to determine left/right facing\n- `UpdateFacingDirection()` calculates whether the entity is moving left or right relative to the camera\n- `SetSpriteFlip()` updates shader parameters via MaterialPropertyBlock\n- Flipping is GPU-based (no sprite regeneration), working with both SpriteRenderer and custom shaders\n\n**Death Handling:**\n\nThe `Die()` virtual method provides a customization point for entity-specific death behaviors:\n- Player death triggers game over sequence\n- Enemy death awards points, spawns pickups\n- Boss death initiates victory sequence\n\n#### EntityManager\n\n**Location:** `Assets/Scripts/Entity/EntityManager.cs`\n\nCentralized registry and query system for all game entities, enabling efficient spatial queries and entity tracking.\n\n**Core Capabilities:**\n\n- **Auto-Discovery**: Automatically finds and registers all Entity instances in the scene during initialization\n- **Spatial Queries**:\n  - `GetEntitiesInRadius(Vector3 pos, float radius)` - Find all entities within circular area\n  - `GetClosestEntity(Vector3 position)` - Find nearest entity to a point\n  - Distance-based queries for AI perception and targeting systems\n- **Type Filtering**: `GetEntitiesOfType\u003CT>()` returns only entities of specific types (e.g., all enemies, all players)\n- **Lifecycle Tracking**: Maintains lists of alive entities, automatically removing dead entities from active queries\n- **Name-Based Lookup**: `GetEntityByName(string name)` for quest systems and scripted encounters\n\n**Use Cases:**\n\n- **AI Target Selection**: Enemies query for nearest player entity\n- **Area of Effect Damage**: Combat systems query for all entities within explosion radius\n- **UI Updates**: Health bars and minimaps query for relevant entities to display\n- **Spawning Logic**: Wave managers check entity counts to determine spawn timing\n\n**Performance Considerations:**\n\nEntityManager caches entity references and uses efficient LINQ queries. For high-frequency spatial queries (hundreds per frame), consider implementing spatial partitioning (quadtree/octree) in future optimization passes.\n\n---\n\n### CameraManager\n\n**Location:** `Assets/Scripts/Core/CameraManager.cs`\n\nThe `CameraManager` provides centralized control over all camera systems in Bug Wars, managing Cinemachine Virtual Cameras and providing utility methods for frustum culling and spatial queries.\n\n**Key Responsibilities:**\n\n- **Virtual Camera Management**:\n  - Auto-discovers all CinemachineVirtualCamera instances in the scene\n  - Caches references for fast lookups without repeated `FindObjectsOfType` calls\n  - Provides API for dynamic camera activation/deactivation via priority system\n- **Camera Target Control**:\n  - Get/Set follow targets for dynamic camera tracking\n  - Get/Set look-at targets for aim control\n  - Supports runtime target switching for cinematic sequences\n- **Frustum Culling Utilities**:\n  - `IsPointInFrustum(Vector3 point)` - Check if world position is visible\n  - `IsBoundsInFrustum(Bounds bounds)` - Check if entire bounding box is visible\n  - `GetFrustumPlanes()` - Get current camera frustum planes for batch culling\n  - Used extensively by TerrainManager for chunk visibility determination\n- **Spatial Queries**:\n  - `GetDistanceFromCamera(Vector3 point)` - Calculate distance for LOD systems\n  - Camera position and forward direction accessors for gameplay logic\n\n**Integration with Terrain System:**\n\nThe CameraManager's frustum culling methods are critical for terrain performance:\n```csharp\n// TerrainManager uses CameraManager for chunk culling\nvar frustumPlanes = cameraManager.GetFrustumPlanes();\nforeach (var chunk in chunks) {\n    bool isVisible = cameraManager.IsBoundsInFrustum(chunk.Bounds);\n    if (isVisible) chunk.Show();\n    else chunk.Hide();\n}\n```\n\n**Cinemachine Integration:**\n\n- **Priority-Based Activation**: Higher priority cameras automatically take control, enabling seamless transitions between gameplay and cinematic cameras\n- **Blend Configuration**: Supports custom blend styles and transition durations\n- **Dynamic Refresh**: `RefreshCameras()` method re-scans scene for newly instantiated virtual cameras\n\n**VContainer Integration:**\n\nRegistered as singleton in GameLifetimeScope, allowing any game system to receive CameraManager via dependency injection for camera-aware functionality.\n\n---\n\n### System Integration & Architecture Flow\n\nBug Wars' systems work together through a well-orchestrated initialization and runtime interaction pattern, leveraging VContainer's dependency injection and EventManager's decoupled communication.\n\n#### Initialization Flow\n\n1. **GameLifetimeScope Startup**:\n   - VContainer container is configured with all manager registrations\n   - Singleton pattern ensures only one instance exists across scenes\n   - DontDestroyOnLoad applied to persist managers through scene transitions\n\n2. **Core System Initialization** (in dependency order):\n   - **EventManager** initializes first with zero dependencies, providing event infrastructure\n   - **InputManager** subscribes to keyboard events and connects to EventManager\n   - **MainMenuManager** configures UI Toolkit elements and event subscriptions\n   - **CameraManager** discovers and caches all Cinemachine Virtual Cameras\n   - **TerrainManager** receives CameraManager dependency and begins async terrain generation\n   - **EntityManager** scans scene for existing entities and registers them\n   - **GameManager** receives all dependencies and coordinates high-level game flow\n\n3. **World Generation**:\n   - TerrainManager generates initial 3x3 chunk grid asynchronously using UniTask\n   - Chunks execute mesh generation on background threads\n   - Mesh application happens on main thread once generation completes\n   - Initial frustum culling pass determines chunk visibility\n\n4. **Game Ready State**:\n   - All managers initialized and ready\n   - Terrain visible and physics colliders active\n   - Entities registered and trackable\n   - Camera system active and responsive\n   - Input system listening for player actions\n\n#### Runtime Interaction Patterns\n\n**Player Movement → Terrain Streaming:**\n- Player entity position changes during gameplay\n- TerrainManager checks player position every frame\n- If player moves beyond chunk distance threshold, trigger chunk loading/unloading\n- New chunks generate asynchronously in background\n- Chunk meshes applied to Unity when generation completes\n\n**Camera Movement → Frustum Culling:**\n- CameraManager tracks main camera transform\n- TerrainManager queries frustum planes periodically (0.5s intervals)\n- Batch culling operation tests all chunk bounds against frustum\n- Visible chunks: `Show()` enables MeshRenderer\n- Hidden chunks: `Hide()` disables MeshRenderer (saves draw calls)\n\n**Input Events → Game State Changes:**\n- InputManager detects Escape key press\n- Triggers `EventManager.TriggerEscapePressed()`\n- GameManager receives event via subscription\n- GameManager calls `MainMenuManager.ToggleMenu()`\n- MainMenuManager updates UI visibility and triggers corresponding event\n\n**Entity Interactions:**\n- Combat system queries EntityManager for enemies in attack range\n- EntityManager returns filtered entity list based on spatial query\n- Entities take damage and update health\n- Dead entities trigger `Die()` method, unregister from EntityManager\n- Death events propagate through EventManager for UI/gameplay updates\n\n**Event-Driven Communication Examples:**\n```csharp\n// System A triggers event\neventManager.TriggerGamePaused();\n\n// System B responds (previously subscribed)\nvoid OnGamePaused() {\n    // Pause terrain generation\n    // Stop entity AI updates\n    // Show pause menu\n}\n```\n\nThis architecture provides several key benefits:\n- **Decoupling**: Systems don't directly reference each other, only interfaces\n- **Testability**: Dependencies can be mocked for unit testing\n- **Maintainability**: Clear dependency chains make code easier to understand\n- **Performance**: Async operations and culling prevent frame drops\n- **Extensibility**: New systems integrate easily through VContainer registration\n\n---\n\n### Combat Mechanics\n\n**Status:** Currently in development\n\nThe combat system will feature:\n- Multiple weapon types with distinct behavior patterns\n- Enemy AI with varying aggression and movement strategies\n- Health and damage systems with visual feedback (base health system implemented in Entity class)\n- Combo mechanics for skilled players\n- Environmental hazards and interactive elements\n\n**Implemented Foundation:**\n- Entity base class provides health, damage, and death functionality\n- EntityManager enables spatial queries for targeting and area-of-effect\n- Billboard sprite system for 2D character rendering in 3D space\n- Physics integration for collision detection and movement\n\n---\n\n### Progression System\n\n**Status:** Planned\n\nBug Wars will implement a multi-layered progression system:\n- Wave-based difficulty scaling with increasing enemy counts and types\n- Resource collection and upgrade paths\n- Persistent unlocks across play sessions\n- Achievement system tracking player milestones\n- Leaderboard integration for competitive players\n\n**System Dependencies:**\n- Will leverage EventManager for achievement triggers\n- EntityManager for tracking kills and statistics\n- Potential SaveManager integration for persistence\n\n---\n\n### Enemy Design\n\n**Status:** Design phase with technical foundation in place\n\nEach bug type will feature unique characteristics:\n- **Ants**: Swarm mechanics with coordinated group attacks\n- **Spiders**: Web-based area denial and ambush tactics\n- **Wasps**: Aerial assault units with ranged stinger attacks\n- **Beetles**: Heavily armored tanks requiring strategic weak point targeting\n- **Boss Enemies**: Multi-phase encounters with unique mechanics\n\n**Technical Foundation:**\n\n- **Entity Base Class**: All enemies will extend Entity base class for consistent behavior (health, damage, movement)\n- **Sprite Rendering Pipeline**: Enemies will follow the Samurai implementation pattern:\n  - Custom sprite atlas JSON defining animations per enemy type\n  - Shared SamuraiAnimatedSprite_Unity6 shader for consistent rendering\n  - MeshRenderer + quad mesh approach for optimal performance\n  - Per-enemy MaterialPropertyBlock for instance-specific frame UVs\n- **Animation States**: Enemies will map universal EntityAnimationState to enemy-specific animations (e.g., `Attack_1` → `\"Bite\"` for ants, `\"Sting\"` for wasps)\n- **GPU Billboarding**: Shader-based billboarding ensures enemies always face camera without CPU overhead\n- **EntityManager Integration**: Spatial awareness for AI decision-making (target acquisition, threat assessment, group behavior)\n- **Physics System**: Ready for enemy collision, movement, and environmental interaction\n\n---\n\n### Camera System (Cinemachine Virtual Cameras)\n\nBug Wars employs a sophisticated camera system powered by Cinemachine to create dynamic, responsive camera behaviors that enhance gameplay clarity and cinematic presentation. The camera is not just a passive observer but an active participant in the game's feel and player experience.\n\nThe CameraManager (detailed above) provides the programmatic interface, while Cinemachine Virtual Cameras define the actual camera behaviors and compositions.\n\n#### Virtual Camera Setup:\n\n**Main Combat Camera (Priority: 10)**\n- **Body**: Framing Transposer - Keeps player character optimally positioned in frame with soft zone dead zones for natural movement\n- **Aim**: Composer - Dynamically frames the player and nearby threats, adjusting composition based on combat intensity\n- **Extensions**: Collision detection to prevent camera clipping, subtle procedural noise for organic feel\n- **Use Case**: Default camera during standard gameplay and combat encounters\n\n**Boss Encounter Camera (Priority: 20)**\n- **Body**: Transposer with wider framing offset to show both player and boss simultaneously\n- **Aim**: Group Composer - Frames both player and boss within the viewport for dramatic confrontations\n- **Extensions**: Impulse listener for impact-based camera shake during boss attacks\n- **Activation**: Triggered by EventManager's boss spawn events, automatically takes priority over combat camera\n\n**Death Camera (Priority: 30)**\n- **Body**: Hard Lock to player position with slow dolly-out effect\n- **Aim**: POV with timed rotation to create dramatic final moments\n- **Activation**: Triggered on player death event, highest priority for cinematic presentation\n\n**Cutscene/Scripted Cameras (Priority: 100)**\n- **Body & Aim**: Varies per sequence, controlled via Timeline integration\n- **Use Case**: Wave completion celebrations, boss introductions, tutorial moments\n\n#### Dynamic Camera Behaviors:\n\n- **Combat Intensity Response**: Camera field of view (FOV) and damping values adjust based on enemy proximity and count - tighter framing during one-on-one encounters, wider framing during swarm situations\n- **Impact Feedback**: Cinemachine Impulse System triggers procedural shake on damage events, with magnitude scaled to damage amount\n- **Smooth Transitions**: Automatic blending between Virtual Cameras using ease-in-out curves for seamless priority changes\n- **Look-Ahead**: Camera anticipates player movement direction, positioning the frame slightly ahead for better visibility\n- **Vertical Reframing**: Automatic camera tilt adjustments when facing flying enemies (wasps) or ground-based threats (beetles)\n\n#### Integration with Game Systems:\n\nThe camera system integrates with Bug Wars' event-driven architecture through EventManager subscriptions:\n- `OnGamePaused` → Reduces camera update rate and locks position\n- `OnGameResumed` → Restores normal camera behavior\n- `OnPlayerHealthChanged` → Triggers intensity-based FOV changes and trauma shake\n- `OnPlayerDied` → Activates death camera sequence\n- Boss-related events → Switch to specialized boss camera rigs\n\nCamera state changes can be sequenced with UniTask for precise timing - for example, awaiting a camera blend completion before starting a boss fight introduction or victory celebration. Custom Cinemachine extensions can receive VContainer-injected dependencies to access GameManager state, enabling camera behaviors that respond to game conditions.\n\n---\n\n## Technical Roadmap\n\n### Completed Systems ✅\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Core Architecture\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - VContainer dependency injection, EventManager, GameManager, InputManager all implemented and operational.\n\t\u003C/Card>\n\t\u003CCard title=\"Terrain Generation System\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - Chunk-based procedural terrain with Perlin noise, async loading, frustum culling, and dynamic streaming.\n\t\u003C/Card>\n\t\u003CCard title=\"Camera Management\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - CameraManager with Cinemachine integration, virtual camera control, frustum culling utilities, and spatial queries.\n\t\u003C/Card>\n\t\u003CCard title=\"Entity System\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - Entity base class with health/damage, EntityManager with spatial queries, animation state system, sprite flipping.\n\t\u003C/Card>\n\t\u003CCard title=\"Sprite Rendering System\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - Custom URP shader with GPU-based billboarding, mesh-based rendering, JSON sprite atlas system, frame-based animation, MaterialPropertyBlock optimization.\n\t\u003C/Card>\n\t\u003CCard title=\"UI Foundation\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - UI Toolkit integration, MainMenuManager with event-driven visibility control.\n\t\u003C/Card>\n\t\u003CCard title=\"Performance Foundation\" icon=\"approve-check\">\n\t\t✅ **COMPLETE** - UniTask async operations, background thread mesh generation, frustum culling, chunk streaming optimization, zero-allocation animation updates.\n\t\u003C/Card>\n\u003C/CardGrid>\n\n### In Progress & Planned Systems 🚧\n\n\u003CCardGrid stagger>\n\t\u003CCard title=\"Physics & Movement\" icon=\"rocket\">\n\t\t🚧 **IN PROGRESS** - Implement responsive character controller with custom physics tuning for tight, responsive gameplay feel. Physics foundation exists via Entity Rigidbody integration.\n\t\u003C/Card>\n\t\u003CCard title=\"Cinemachine Virtual Cameras\" icon=\"star\">\n\t\t🚧 **IN PROGRESS** - Configure specific Virtual Camera rigs for combat, boss encounters, and cinematic sequences with dynamic blending and procedural behaviors. CameraManager infrastructure complete.\n\t\u003C/Card>\n\t\u003CCard title=\"AI Behavior Trees\" icon=\"puzzle\">\n\t\t📋 **PLANNED** - Develop modular AI system using behavior trees for complex enemy decision-making and state management. EntityManager provides spatial awareness foundation.\n\t\u003C/Card>\n\t\u003CCard title=\"Combat System\" icon=\"swords\">\n\t\t📋 **PLANNED** - Create weapon framework with hit detection, damage calculation, and visual effects integration. Entity health system provides foundation.\n\t\u003C/Card>\n\t\u003CCard title=\"Audio System\" icon=\"information\">\n\t\t📋 **PLANNED** - Integrate spatial audio with dynamic mixing, music states, and procedural sound effect layers.\n\t\u003C/Card>\n\t\u003CCard title=\"Save System\" icon=\"document\">\n\t\t📋 **PLANNED** - Implement serialization framework for player progress, settings, and unlockables with cloud backup support.\n\t\u003C/Card>\n\t\u003CCard title=\"Advanced Performance\" icon=\"approve-check\">\n\t\t📋 **PLANNED** - Profile and optimize rendering, physics, and gameplay systems to target 60 FPS on all supported platforms. Current optimizations already in place (culling, async).\n\t\u003C/Card>\n\t\u003CCard title=\"Wave System\" icon=\"puzzle\">\n\t\t📋 **PLANNED** - Implement wave-based enemy spawning with difficulty scaling and progression mechanics.\n\t\u003C/Card>\n\u003C/CardGrid>\n\n### Recent Accomplishments (Last 2 Weeks)\n\n- **Sprite Rendering System**: Implemented custom URP shader with GPU-based billboarding (cylindrical and spherical modes)\n- **Mesh-Based Rendering**: Replaced SpriteRenderer with MeshRenderer + custom shader for material control and performance\n- **Sprite Atlas System**: Created JSON-driven sprite atlas format with frame definitions and animation sequences using Newtonsoft.Json\n- **Samurai Character**: Implemented complete player character with frame-based animation, atlas loading, and shader integration\n- **Animation State System**: Universal EntityAnimationState enum with character-specific mapping for polymorphic animation control\n- **MaterialPropertyBlock Optimization**: Zero-allocation animation updates via cached shader property IDs and property block reuse\n- **Camera Focus Fix**: Resolved camera tracking issues to properly follow player character\n- **Sprite Flipping System**: Camera-relative directional flipping via shader parameters (_FlipX, _FlipY)\n- Quadrupled terrain chunk size from 20x20 to 80x80 units for better performance/detail ratio\n- Implemented async chunk loading/unloading with distance-based triggers\n- Added frustum culling integration between TerrainManager and CameraManager\n- Developed CameraManager with Cinemachine utilities and spatial query methods\n- Built EntityManager with spatial query capabilities (radius searches, closest entity, type filtering)\n- Refactored logging across all systems with defensive null checks\n- Integrated all new systems into VContainer dependency injection pipeline\n\n---\n\n## Development Guidelines\n\n### Code Standards\n\n- All public methods and classes must include XML documentation comments\n- Use explicit access modifiers (never rely on implicit `private`)\n- Follow Unity's component lifecycle patterns (Awake, Start, Update, OnDestroy)\n- Prefer composition over inheritance for gameplay features\n- Use `readonly` and `const` where appropriate to prevent accidental mutations\n\n### Architecture Principles\n\n- **Dependency Injection**: All managers and controllers use VContainer for dependency resolution\n- **Event-Driven Communication**: Systems communicate through EventManager rather than direct references\n- **Async/Await**: Prefer UniTask over coroutines for asynchronous operations\n- **Single Responsibility**: Each class should have one clear, well-defined purpose\n- **Testability**: Design with unit testing in mind - dependencies should be mockable\n\n### Version Control\n\n- Branch naming: `feature/description`, `bugfix/issue-number`, `refactor/system-name`\n- Commit messages should be descriptive and reference issue numbers\n- All code must pass automated tests before merging to main branch\n- Unity meta files must be committed with corresponding assets\n\n---\n\n## Game Advertising Strategy\n\nBug Wars' success depends not only on solid development but also on effective marketing and community outreach. This section outlines our advertising strategy across multiple platforms and details the visual assets required to support these campaigns.\n\n### Target Advertising Platforms\n\n#### Itch.io\n\n[Itch.io](https://itch.io) is a premier indie game distribution platform with a vibrant community of indie game enthusiasts, developers, and players who actively seek out unique gaming experiences.\n\n**Platform Strategy:**\n- **Game Page Optimization**: Create a compelling game page with rich media (screenshots, GIFs, gameplay videos) showcasing Bug Wars' unique mechanics\n- **Tag Strategy**: Utilize relevant tags such as `action`, `survival`, `waves`, `unity`, `arcade`, `singleplayer`, `insects`, `combat`\n- **Devlog Series**: Regular development updates with behind-the-scenes content about VContainer architecture, Cinemachine camera work, and AI behavior implementation\n- **Demo Release**: Launch a free demo version (WebGL build) to reduce friction for player acquisition and gather early feedback\n- **Community Engagement**: Respond to comments, participate in jams, and cross-promote with similar indie titles\n- **Pricing Strategy**: Consider a pay-what-you-want model during beta with a suggested price, transitioning to fixed pricing at full release\n- **Bundle Participation**: Collaborate with other developers for themed bundles (indie action games, survival games, etc.)\n\n**Best Practices:**\n- Upload WebGL builds for instant browser playability (reduces barrier to entry)\n- Include detailed changelog with each update to show active development\n- Create an engaging cover image (630x500px minimum) that captures the game's action and bug-themed aesthetic\n- Add press kit download links for journalists and content creators\n\n#### Hacker News\n\n[Hacker News](https://news.ycombinator.com) is a technology-focused community with a strong interest in software development, game engines, and technical achievements. The audience skews toward engineers and technical professionals.\n\n**Platform Strategy:**\n- **Technical Deep-Dives**: Share \"Show HN\" posts focused on technical accomplishments - VContainer architecture, UniTask performance optimizations, or AI-assisted development with MCP\n- **Architecture Articles**: Write blog posts about solving technical challenges (e.g., \"Building a Zero-Allocation Game Architecture with VContainer and UniTask\")\n- **Open Source Contributions**: If appropriate, open-source non-core systems (camera utilities, event manager patterns) and share them with the community\n- **Timing**: Post during high-traffic periods (weekday mornings US EST, around 8-10 AM)\n- **Title Crafting**: Focus on technical value - \"Bug Wars: Building a Unity Game with Dependency Injection and Zero-Allocation Async\" performs better than \"Check out my new game\"\n- **Comment Engagement**: Be prepared to answer technical questions and engage in architectural discussions\n\n**Best Practices:**\n- Link to technical blog posts or GitHub repos rather than direct sales pages\n- Provide technical insights and learnings that benefit the broader development community\n- Include WebGL demo links for instant playability (HN users appreciate browser-accessible content)\n- Be transparent about development challenges and solutions\n- Avoid overly promotional language - focus on technical merit and interesting problems solved\n\n#### Craigslist\n\n[Craigslist](https://craigslist.org) offers localized community-based advertising with surprisingly engaged gaming communities in major metropolitan areas.\n\n**Platform Strategy:**\n- **Community Section**: Post in the \"community > activities\" or \"for sale > video gaming\" sections of major cities\n- **Local Gaming Groups**: Target cities with active gaming communities (San Francisco, Los Angeles, New York, Seattle, Austin, etc.)\n- **Event Tie-Ins**: Coordinate posts with local gaming events, conventions, or meetups\n- **Beta Testing Recruitment**: Use Craigslist to recruit local beta testers who can provide in-person feedback sessions\n- **University Outreach**: Post in college town Craigslist sites targeting computer science and game design student communities\n\n**Post Structure:**\n- Clear, concise title: \"Free Indie Action Game: Bug Wars - Beta Testers Wanted\" or \"New Unity Game Launch - Bug-Themed Survival Action\"\n- Brief description with bullet points highlighting key features\n- Call-to-action with direct download/play links\n- Optional: Include local gaming community Discord/meetup information\n- Refresh posts every 7-14 days to maintain visibility\n\n**Best Practices:**\n- Follow Craigslist posting guidelines carefully to avoid flags/removal\n- Use local language and references when appropriate\n- Include clear contact information or links (email, Discord, game page URL)\n- Avoid spam-like behavior - space out posts across different city sections\n- Consider offering special items/credits for local players who provide feedback\n\n#### Reddit (r/sideproject)\n\n[Reddit's r/sideproject](https://reddit.com/r/sideproject) is a community where creators share their projects, receive feedback, and connect with potential users. The subreddit has over 300k members interested in entrepreneurship, indie development, and creative projects.\n\n**Platform Strategy:**\n- **Launch Announcements**: Share major milestones (beta launch, full release, significant updates) with detailed posts\n- **Behind-the-Scenes Content**: Create posts showing development journey, technical challenges overcome, and lessons learned\n- **Feedback Requests**: Engage the community for UX feedback, feature suggestions, and playtesting\n- **Follow-Up Posts**: Update the community on progress based on their feedback, showing iteration and responsiveness\n- **Cross-Posting**: Consider sharing to related subreddits like r/Unity3D, r/gamedev, r/IndieGaming, r/WebGames (for WebGL builds)\n\n**Post Structure Best Practices:**\n- **Engaging Title**: \"I built a survival action game with Unity where you fight waves of insects - 6 months of nights/weekends\"\n- **Opening Hook**: Lead with the most interesting aspect (technical achievement, unique gameplay mechanic, development story)\n- **Project Summary**: Clear explanation of what Bug Wars is and what makes it unique\n- **Technical Stack**: r/sideproject appreciates technical details - mention Unity, VContainer, UniTask, WebGL deployment\n- **Call to Action**: Direct link to play (itch.io WebGL build ideal) and request for specific feedback\n- **Development Stats**: Include interesting metrics (lines of code, hours invested, iterations, etc.)\n- **Visuals**: Embed GIFs or images directly in the post (Reddit's image hosting preferred)\n\n**Engagement Guidelines:**\n- Respond to every comment within the first 2-3 hours (critical for Reddit algorithm visibility)\n- Be transparent about challenges and failures (Reddit values authenticity)\n- Avoid overly promotional language - focus on journey and learning\n- Thank users for feedback and show how you're incorporating suggestions\n- Consider hosting an impromptu AMA if post gains significant traction\n\n**Timing:**\n- Post Tuesday-Thursday, 8-11 AM EST for maximum visibility\n- Avoid Fridays and weekends (lower engagement on r/sideproject)\n\n**Additional Relevant Subreddits:**\n- r/Unity3D (200k+ members, technical Unity discussions)\n- r/gamedev (1M+ members, weekly feedback threads)\n- r/IndieGaming (300k+ members, indie game showcases)\n- r/WebGames (600k+ members, specifically for browser-playable games)\n- r/PlayMyGame (50k+ members, focused on playtesting and feedback)\n\n### Visual Assets & Infographics Strategy\n\nEffective game advertising requires a comprehensive suite of visual assets optimized for different platforms and use cases. This section details the infographics and image assets needed to maximize Bug Wars' marketing impact.\n\n#### Core Visual Asset Types\n\n**1. Hero Banner / Key Art**\n- **Dimensions**: 1920x1080px (16:9 ratio) for web use, 3840x2160px for high-resolution displays\n- **Purpose**: Primary marketing image showcasing the game's theme, tone, and visual identity\n- **Content**: Dynamic composition featuring player character surrounded by enemy bugs, emphasizing action and survival themes\n- **Use Cases**: Website headers, press kit, social media cover images, Itch.io banner\n- **Style**: High-contrast, vibrant colors that work well when downsized for thumbnails\n\n**2. Gameplay Screenshots**\n- **Dimensions**: 1920x1080px (native Unity resolution)\n- **Quantity**: Minimum 6-8 varied screenshots showing different aspects of gameplay\n- **Content Variety**:\n  - Early game combat (showing tutorial/learning curve)\n  - Mid-game intensity (swarm encounters with multiple enemy types)\n  - Boss encounter (dramatic framing with Cinemachine camera angles)\n  - UI/HUD demonstration (clear visibility of game interface)\n  - Environmental variety (different arena types or settings)\n  - Victory/progression moments (player success, upgrades, achievements)\n- **Post-Processing**: Subtle color correction and sharpening, avoid over-editing that misrepresents actual gameplay\n- **Use Cases**: Itch.io gallery, Reddit posts, press kit, store pages\n\n**3. Animated GIFs**\n- **Dimensions**: 800x450px to 1280x720px (balance between quality and file size)\n- **Duration**: 3-8 seconds, seamlessly looping\n- **Frame Rate**: 30 FPS (smooth motion without excessive file size)\n- **File Size Target**: Under 5MB for fast loading on web platforms\n- **Content Ideas**:\n  - Combat loop demonstration (player attacking, dodging, defeating enemies)\n  - Enemy behavior showcase (unique bug attack patterns and movement)\n  - Camera system highlight (Cinemachine dynamic framing and shake effects)\n  - Upgrade/progression moment (visual feedback when leveling up)\n  - Swarm intensity ramp-up (showing wave escalation)\n- **Technical Creation**: Use Unity Recorder package or screen capture tools like ShareX, OBS\n- **Optimization**: Use GIPHY's compression tools or ezgif.com to reduce file size while maintaining quality\n- **Use Cases**: Reddit posts, Twitter/X posts, Itch.io gallery, README files\n\n**4. Logo & Branding Assets**\n- **Logo Variations**:\n  - Full color on transparent background (PNG, 2048x2048px square)\n  - White version for dark backgrounds (PNG, 2048x2048px)\n  - Black version for light backgrounds (PNG, 2048x2048px)\n  - Favicon (256x256px, 64x64px, 32x32px, 16x16px)\n- **Typography**: Document primary font choices for \"Bug Wars\" wordmark\n- **Color Palette**: Define primary brand colors (hex codes) for consistent visual identity\n- **Use Cases**: Website favicon, social media avatars, watermarks, press kit\n\n**5. Infographics**\n\n**Game Features Infographic**\n- **Dimensions**: 1200x3000px (vertical scroll format ideal for Reddit/blog posts)\n- **Content Sections**:\n  - Game overview with logo and tagline\n  - Core mechanics breakdown (combat, progression, enemies)\n  - Technical stack visualization (Unity + VContainer + UniTask + Cinemachine)\n  - Development timeline/roadmap\n  - Platform availability (WebGL browser, Windows, Mac, Linux)\n- **Style**: Clean, modern design with icons and minimal text\n- **Tools**: Canva, Figma, Adobe Illustrator\n\n**Enemy Types Infographic**\n- **Dimensions**: 1920x1080px (landscape for easy sharing)\n- **Content**: Visual guide showing each enemy type with:\n  - Enemy sprite/3D model preview\n  - Name and difficulty tier\n  - Key behaviors and attack patterns\n  - Tactical tips for players\n- **Purpose**: Educational content that doubles as marketing material\n- **Use Cases**: Blog posts, Reddit strategy guides, Steam community discussions\n\n**Development Tech Stack Infographic**\n- **Dimensions**: 1200x1200px (square for social media)\n- **Content**: Visual representation of Bug Wars' technical architecture:\n  - Unity Engine (central node)\n  - VContainer (dependency injection layer)\n  - UniTask (async operations)\n  - Cinemachine (camera system)\n  - UI Toolkit (interface)\n  - Model Context Protocol (AI-assisted development)\n- **Style**: Node-based diagram or layered architecture visualization\n- **Purpose**: Technical marketing for developer communities (Hacker News, r/Unity3D, r/gamedev)\n\n**6. Social Media Assets**\n\n**Twitter/X Card**\n- **Dimensions**: 1200x675px (16:9 ratio)\n- **Content**: Eye-catching gameplay moment or key art with minimal text overlay\n- **Purpose**: Optimized preview when sharing links on Twitter/X\n\n**Open Graph Image (Facebook/LinkedIn)**\n- **Dimensions**: 1200x630px (1.91:1 ratio)\n- **Content**: Similar to Twitter card but with slightly different aspect ratio\n- **Purpose**: Preview image when sharing on Facebook, LinkedIn, Discord\n\n**Instagram/Square Format**\n- **Dimensions**: 1080x1080px (1:1 ratio)\n- **Content**: Cropped/reformatted key art or gameplay screenshots\n- **Purpose**: Instagram posts, Twitter media attachments, Discord avatars\n\n**7. Video Assets**\n\n**Launch Trailer**\n- **Duration**: 60-90 seconds\n- **Content**: Fast-paced montage of gameplay highlights, enemy encounters, and progression moments\n- **Music**: Energetic, action-oriented soundtrack matching game's intensity\n- **Text Overlays**: Key features, platform availability, release date/availability\n- **Call-to-Action**: End screen with itch.io link and \"Play Now\" text\n- **Formats**: Export in 1080p60 and 4K60 for different platforms\n- **Use Cases**: YouTube, Itch.io page, social media, press kit\n\n**Gameplay Deep-Dive Video**\n- **Duration**: 3-5 minutes\n- **Content**: Narrated or text-overlay walkthrough explaining core mechanics, enemy types, and progression\n- **Purpose**: Educational content for players interested in understanding game systems\n- **Use Cases**: YouTube, Itch.io devlog, tutorial resource\n\n**Technical Developer Commentary**\n- **Duration**: 10-20 minutes\n- **Content**: Behind-the-scenes technical discussion of architecture, Unity systems, and development challenges\n- **Target Audience**: Game developers, Unity enthusiasts, technical community (Hacker News audience)\n- **Use Cases**: YouTube, blog post embed, conference talk material\n\n#### Asset Organization & Management\n\n**Press Kit Structure**\n```\nBugWars_PressKit/\n├── Images/\n│   ├── KeyArt/\n│   │   ├── BugWars_KeyArt_4K.png\n│   │   └── BugWars_KeyArt_1080p.png\n│   ├── Screenshots/\n│   │   ├── BugWars_Screenshot_01.png\n│   │   └── ... (6-8 total)\n│   ├── Logos/\n│   │   ├── BugWars_Logo_Color.png\n│   │   ├── BugWars_Logo_White.png\n│   │   └── BugWars_Logo_Black.png\n│   └── Social/\n│       ├── TwitterCard_1200x675.png\n│       ├── OpenGraph_1200x630.png\n│       └── Square_1080x1080.png\n├── Videos/\n│   ├── BugWars_LaunchTrailer_1080p60.mp4\n│   └── BugWars_LaunchTrailer_4K60.mp4\n├── GIFs/\n│   ├── Combat_Loop.gif\n│   ├── Boss_Encounter.gif\n│   └── Swarm_Mechanics.gif\n├── Infographics/\n│   ├── GameFeatures_Infographic.png\n│   └── TechStack_Infographic.png\n└── BugWars_FactSheet.pdf\n```\n\n**Fact Sheet Contents**\n- Game title, tagline, and elevator pitch\n- Developer name and contact information\n- Release date and platform availability\n- Key features (bullet points)\n- Technical specifications (Unity version, system requirements)\n- Link to gameplay trailer and website\n- High-resolution logo files reference\n- Social media handles and press contact\n\n#### Asset Creation Workflow\n\n**Tools & Software:**\n- **Unity Recorder Package**: For capturing gameplay footage and screenshots at consistent quality\n- **OBS Studio**: For longer gameplay recordings and live capture\n- **GIPHY/ezgif.com**: For GIF optimization and editing\n- **Canva/Figma**: For infographic design (non-technical team members)\n- **Adobe Creative Suite**: For professional-grade asset creation (Photoshop, Illustrator, Premiere Pro)\n- **DaVinci Resolve**: Free alternative for video editing\n- **ShareX**: Quick screenshot and GIF capture tool (Windows)\n\n**Capture Best Practices:**\n- Record gameplay at native 1920x1080 resolution for consistency\n- Use Unity's Frame Debugger to capture perfect timing moments\n- Disable debug UI elements and development overlays before capturing\n- Capture during stable builds to avoid visual glitches in marketing materials\n- Maintain consistent visual quality across all assets\n- Version control assets alongside code (large files in Git LFS or separate cloud storage)\n\n**Optimization Guidelines:**\n- **PNGs**: Use TinyPNG or ImageOptim to reduce file sizes without visible quality loss\n- **GIFs**: Target 3-5MB max for fast web loading, use lossy compression if needed\n- **Videos**: H.264 codec with moderate compression (CRF 23-28) for web delivery\n- **Responsive Versions**: Create multiple size variants for different devices and platforms\n\n---\n\n## Resources & References\n\n### Core Unity Technologies\n- [VContainer Documentation](https://vcontainer.hadashia.com/)\n- [UniTask Documentation](https://github.com/Cysharp/UniTask)\n- [Cinemachine Documentation](https://docs.unity3d.com/Packages/com.unity.cinemachine@latest)\n- [Unity UI Toolkit Guide](https://docs.unity3d.com/Manual/UIElements.html)\n- [Unity Input System](https://docs.unity3d.com/Packages/com.unity.inputsystem@latest)\n\n### AI-Assisted Development Tools\n- [Unity MCP (Model Context Protocol)](https://github.com/CoplayDev/unity-mcp)\n- [Context7 Unity Documentation](https://context7.com?q=unity)\n- [Context7 GitHub Repository](https://github.com/upstash/context7)\n\n---\n\n*Last Updated: 2025-01-11 - Added Sprite Rendering System documentation (custom URP shader, mesh-based rendering, sprite atlas system, Samurai character implementation)*","src/content/docs/gdd.mdx","58f16e46fc297700","blog",{"id":184,"data":186,"body":192,"filePath":193,"digest":194,"deferredRender":16},{"title":187,"description":188,"editUrl":16,"head":189,"template":103,"sidebar":190,"pagefind":16,"draft":39},"Bug Wars Dev Blog","Development updates, technical insights, and behind-the-scenes stories from the Bug Wars project",[],{"hidden":39,"attrs":191},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n\n# Bug Wars Development Blog\n\nWelcome to the Bug Wars development blog! This is where we share updates about the game's progress, technical challenges we've overcome, design decisions, and insights into the development process.\n\n## What to Expect\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"Technical Deep Dives\" icon=\"laptop\">\n    Detailed explanations of the systems and technologies powering Bug Wars, from Unity architecture to gameplay mechanics.\n  \u003C/Card>\n  \u003CCard title=\"Progress Updates\" icon=\"rocket\">\n    Regular updates on new features, improvements, and milestones as we build the game.\n  \u003C/Card>\n  \u003CCard title=\"Design Decisions\" icon=\"puzzle\">\n    Insights into why we made specific choices in gameplay, UI, and technical architecture.\n  \u003C/Card>\n  \u003CCard title=\"Lessons Learned\" icon=\"open-book\">\n    Challenges we've faced, mistakes we've made, and what we learned from them.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## Recent Posts\n\n*Blog posts will appear here as they are published. Stay tuned for our first dev log!*\n\n## Topics We'll Cover\n\n- Unity game development best practices\n- VContainer and dependency injection patterns\n- UniTask async/await implementation\n- Combat system design and iteration\n- AI behavior and enemy design\n- Performance optimization techniques\n- WebGL build process and optimization\n- UI/UX design with Unity UI Toolkit\n- Sound design and audio integration\n- Testing and debugging strategies\n\n## Follow Development\n\nWant to stay updated on Bug Wars development?\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"Check the GDD\" icon=\"document\">\n    Read our comprehensive [Game Design Document](/gdd) for technical details about the game's architecture.\n  \u003C/Card>\n  \u003CCard title=\"Play the Game\" icon=\"rocket\">\n    Try the latest build on our [Game Page](/game) and experience the current state of development.\n  \u003C/Card>\n  \u003CCard title=\"GitHub Repository\" icon=\"github\">\n    Follow the project on GitHub to see code changes and contribute to the development.\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\nimport AstroMainHero from '@/components/hero/mainhero/AstroMainHero.astro';\n\n\u003CAstroMainHero\n  title=\"Welcome to BugWars\"\n  subtitle=\"Epic Bug Battles\"\n  description=\"Enter the arena and fight bugs in epic multiplayer battles\"\n  ctaText=\"Play Now\"\n  ctaUrl=\"/play\"\n  secondaryCtaText=\"Learn More\"\n  secondaryCtaUrl=\"/about\"\n  backgroundImage=\"/images/hero-bg.jpg\"\n  height=\"100vh\"\n  enableParallax={true}\n  showScrollIndicator={true}\n/>\n\n---\n\n*Last Updated: 2025-11-10*","src/content/docs/blog/index.mdx","4c63a59d3777a3a3","es/game",{"id":195,"data":197,"body":208,"filePath":209,"assetImports":210,"digest":212,"deferredRender":16},{"title":198,"description":199,"editUrl":16,"head":200,"template":18,"hero":201,"sidebar":206,"pagefind":16,"draft":39},"Juega a Bug Wars\n","Experimenta Bug Wars en tu navegador con Unity WebGL\n",[],{"tagline":202,"image":203,"actions":205},"Sobrevive al enjambre. Demuestra tu valía.",{"alt":22,"file":204},"__ASTRO_IMAGE_../../../assets/BugWars.webp",[],{"hidden":39,"attrs":207},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## Juega a Bug Wars en tu Navegador\n\nPrepárate para enfrentar el desafío definitivo de supervivencia. Bug Wars se ejecuta directamente en tu navegador usando tecnología Unity WebGL - no se requiere instalación.\n\n{/* Unity WebGL container will be injected here when the build is ready */}\n\u003Cdiv id=\"unity-game-wrapper\" style=\"margin: 2rem 0;\">\n  \u003Cdiv id=\"unity-loading-placeholder\" style=\"text-align: center; padding: 4rem 2rem; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%); border-radius: 12px; border: 2px dashed rgba(99, 102, 241, 0.3);\">\n    \u003Ch3 style=\"margin-bottom: 1rem; color: #6366f1;\">Compilación Unity WebGL Próximamente\u003C/h3>\n    \u003Cp style=\"color: #94a3b8; max-width: 600px; margin: 0 auto;\">\n      El juego está actualmente en desarrollo. Una vez que la compilación Unity WebGL esté lista, se incrustará aquí para jugar instantáneamente en el navegador.\n    \u003C/p>\n    \u003Cp style=\"margin-top: 1.5rem; font-size: 0.875rem; color: #64748b;\">\n      Características esperadas: Gráficos 3D completos, controles responsivos, combate basado en oleadas y diseño de sonido inmersivo.\n    \u003C/p>\n  \u003C/div>\n\u003C/div>\n\n## Controles del Juego\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"Movimiento\" icon=\"right-arrow\">\n    Usa WASD o las Flechas para navegar por el campo de batalla y esquivar ataques enemigos.\n  \u003C/Card>\n  \u003CCard title=\"Combate\" icon=\"rocket\">\n    Clic Izquierdo o Espacio para atacar. Sincroniza tus golpes cuidadosamente para maximizar el daño.\n  \u003C/Card>\n  \u003CCard title=\"Habilidades Especiales\" icon=\"star\">\n    Presiona E o Clic Derecho para activar habilidades especiales cuando estén disponibles.\n  \u003C/Card>\n  \u003CCard title=\"Menú de Pausa\" icon=\"setting\">\n    Presiona ESC para pausar el juego y acceder a configuraciones o volver al menú principal.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## Consejos del Juego\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"Mantente en Movimiento\" icon=\"rocket\">\n    El movimiento constante es clave para sobrevivir. Quedarse quieto te convierte en un blanco fácil para los enjambres.\n  \u003C/Card>\n  \u003CCard title=\"Prioriza Amenazas\" icon=\"warning\">\n    Concéntrate primero en los enemigos más peligrosos. Algunos insectos infligen más daño o se mueven más rápido que otros.\n  \u003C/Card>\n  \u003CCard title=\"Administra Recursos\" icon=\"star\">\n    Usa las habilidades especiales sabiamente. Guárdalas para situaciones abrumadoras o encuentros difíciles con jefes.\n  \u003C/Card>\n  \u003CCard title=\"Aprende Patrones\" icon=\"open-book\">\n    Cada oleada tiene patrones predecibles. Estudia el comportamiento enemigo para anticipar ataques.\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv style=\"text-align: center; margin-top: 3rem; padding: 2rem; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%); border-radius: 12px;\">\n  \u003Ch3 style=\"margin-bottom: 0.5rem;\">¿Listo para Luchar?\u003C/h3>\n  \u003Cp style=\"color: #94a3b8;\">Los insectos están esperando. Muéstrales de qué estás hecho.\u003C/p>\n\u003C/div>","src/content/docs/es/game.mdx",[211],"../../../assets/BugWars.webp","1ecdf02b527fb4f8","es/gdd",{"id":213,"data":215,"body":221,"filePath":222,"digest":223,"deferredRender":16},{"title":216,"description":217,"editUrl":16,"head":218,"template":103,"sidebar":219,"pagefind":16,"draft":39},"Bug Wars - Documento de Diseño del Juego","Documentación técnica completa del proyecto de juego Bug Wars en Unity",[],{"hidden":39,"attrs":220},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Bug Wars - Documento de Diseño del Juego\n\n*Traducción en progreso. Por favor, consulte la [versión en inglés](/gdd) para la documentación completa.*\n\n## Descripción General del Juego\n\n**Bug Wars** es un juego de acción y supervivencia construido en Unity donde los jugadores se enfrentan a oleadas implacables de insectos y criaturas del mundo natural. El juego presenta mecánicas de combate intensas, gestión estratégica de recursos y escalado progresivo de dificultad.\n\n---\n\n*Para la documentación técnica completa, consulte la [versión en inglés del GDD](/gdd).*\n\n*Última actualización: 2025-11-10*","src/content/docs/es/gdd.mdx","c4e6a4495019de3d","ja/game",{"id":224,"data":226,"body":236,"filePath":237,"assetImports":238,"digest":239,"deferredRender":16},{"title":227,"description":228,"editUrl":16,"head":229,"template":18,"hero":230,"sidebar":234,"pagefind":16,"draft":39},"Bug Warsをプレイ\n","Unity WebGLでブラウザ上でBug Warsを体験\n",[],{"tagline":231,"image":232,"actions":233},"群れから生き残れ。その価値を証明せよ。",{"alt":22,"file":204},[],{"hidden":39,"attrs":235},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## ブラウザでBug Warsをプレイ\n\n究極のサバイバルチャレンジに立ち向かう準備をしましょう。Bug WarsはUnity WebGL技術を使用してブラウザで直接動作します - インストール不要です。\n\n{/* Unity WebGL container will be injected here when the build is ready */}\n\u003Cdiv id=\"unity-game-wrapper\" style=\"margin: 2rem 0;\">\n  \u003Cdiv id=\"unity-loading-placeholder\" style=\"text-align: center; padding: 4rem 2rem; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%); border-radius: 12px; border: 2px dashed rgba(99, 102, 241, 0.3);\">\n    \u003Ch3 style=\"margin-bottom: 1rem; color: #6366f1;\">Unity WebGLビルド近日公開\u003C/h3>\n    \u003Cp style=\"color: #94a3b8; max-width: 600px; margin: 0 auto;\">\n      ゲームは現在開発中です。Unity WebGLビルドの準備ができたら、ここに埋め込まれ、ブラウザベースのゲームプレイが可能になります。\n    \u003C/p>\n    \u003Cp style=\"margin-top: 1.5rem; font-size: 0.875rem; color: #64748b;\">\n      予定機能: フル3Dグラフィックス、レスポンシブコントロール、ウェーブベースの戦闘、没入型サウンドデザイン。\n    \u003C/p>\n  \u003C/div>\n\u003C/div>\n\n## ゲームコントロール\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"移動\" icon=\"right-arrow\">\n    WASDまたは矢印キーを使用して戦場を移動し、敵の攻撃を回避します。\n  \u003C/Card>\n  \u003CCard title=\"戦闘\" icon=\"rocket\">\n    左クリックまたはスペースで攻撃。タイミングを計って攻撃し、ダメージを最大化しましょう。\n  \u003C/Card>\n  \u003CCard title=\"特殊能力\" icon=\"star\">\n    EキーまたはRight Clickで利用可能な特殊能力を発動します。\n  \u003C/Card>\n  \u003CCard title=\"ポーズメニュー\" icon=\"setting\">\n    ESCキーを押してゲームを一時停止し、設定にアクセスするか、メインメニューに戻ります。\n  \u003C/Card>\n\u003C/CardGrid>\n\n## ゲームのヒント\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"動き続ける\" icon=\"rocket\">\n    常に動き続けることが生存の鍵です。じっとしていると、群れの格好の標的になります。\n  \u003C/Card>\n  \u003CCard title=\"脅威の優先順位\" icon=\"warning\">\n    最も危険な敵から倒しましょう。一部のバグは他のバグよりも多くのダメージを与えたり、速く動いたりします。\n  \u003C/Card>\n  \u003CCard title=\"リソース管理\" icon=\"star\">\n    特殊能力は賢く使いましょう。圧倒的な状況や難しいボス戦のために温存しておきましょう。\n  \u003C/Card>\n  \u003CCard title=\"パターンを学ぶ\" icon=\"open-book\">\n    各ウェーブには予測可能なパターンがあります。敵の行動を研究して攻撃を予測しましょう。\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv style=\"text-align: center; margin-top: 3rem; padding: 2rem; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%); border-radius: 12px;\">\n  \u003Ch3 style=\"margin-bottom: 0.5rem;\">戦う準備はできましたか？\u003C/h3>\n  \u003Cp style=\"color: #94a3b8;\">バグたちが待っています。あなたの実力を見せつけましょう。\u003C/p>\n\u003C/div>","src/content/docs/ja/game.mdx",[211],"9cfb777fdf747693","ja/gdd",{"id":240,"data":242,"body":248,"filePath":249,"digest":250,"deferredRender":16},{"title":243,"description":244,"editUrl":16,"head":245,"template":103,"sidebar":246,"pagefind":16,"draft":39},"Bug Wars - ゲームデザインドキュメント","Bug Wars Unityゲームプロジェクトの包括的な技術文書",[],{"hidden":39,"attrs":247},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Bug Wars - ゲームデザインドキュメント\n\n*翻訳作業中です。完全なドキュメントについては、[英語版](/gdd)をご覧ください。*\n\n## ゲーム概要\n\n**Bug Wars**は、Unityで構築されたサバイバルアクションゲームで、プレイヤーは自然界の昆虫や生物の容赦ない波に立ち向かいます。激しい戦闘メカニクス、戦略的なリソース管理、段階的な難易度スケーリングが特徴です。\n\n---\n\n*完全な技術文書については、[英語版GDD](/gdd)をご参照ください。*\n\n*最終更新: 2025-11-10*","src/content/docs/ja/gdd.mdx","3b3a7ac610678494","ko/gdd",{"id":251,"data":253,"body":259,"filePath":260,"digest":261,"deferredRender":16},{"title":254,"description":255,"editUrl":16,"head":256,"template":103,"sidebar":257,"pagefind":16,"draft":39},"Bug Wars - 게임 디자인 문서","Bug Wars Unity 게임 프로젝트의 포괄적인 기술 문서",[],{"hidden":39,"attrs":258},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Bug Wars - 게임 디자인 문서\n\n*번역 작업 중입니다. 전체 문서는 [영문 버전](/gdd)을 참조해 주세요.*\n\n## 게임 개요\n\n**Bug Wars**는 Unity로 제작된 생존 액션 게임으로, 플레이어는 자연계의 곤충과 생물들의 끊임없는 공격 물결에 맞서 싸웁니다. 격렬한 전투 메커니즘, 전략적 자원 관리, 점진적 난이도 증가가 특징입니다.\n\n---\n\n*전체 기술 문서는 [영문 GDD](/gdd)를 참조하세요.*\n\n*최종 업데이트: 2025-11-10*","src/content/docs/ko/gdd.mdx","9e7e42853e5ee60b","ja/blog",{"id":262,"data":264,"body":270,"filePath":271,"digest":272,"deferredRender":16},{"title":265,"description":266,"editUrl":16,"head":267,"template":103,"sidebar":268,"pagefind":16,"draft":39},"Bug Wars 開発ブログ","Bug Warsプロジェクトの開発アップデート、技術的洞察、舞台裏のストーリー",[],{"hidden":39,"attrs":269},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Bug Wars 開発ブログ\n\nBug Wars開発ブログへようこそ！ここでは、ゲームの進捗、克服した技術的課題、設計の決定、開発プロセスへの洞察を共有しています。\n\n## 期待できること\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"技術的な深掘り\" icon=\"laptop\">\n    Unityアーキテクチャからゲームプレイメカニクスまで、Bug Warsを動かすシステムと技術の詳細な説明。\n  \u003C/Card>\n  \u003CCard title=\"進捗アップデート\" icon=\"rocket\">\n    ゲームを構築する際の新機能、改善、マイルストーンに関する定期的な更新。\n  \u003C/Card>\n  \u003CCard title=\"設計の決定\" icon=\"puzzle\">\n    ゲームプレイ、UI、技術アーキテクチャにおける特定の選択をした理由についての洞察。\n  \u003C/Card>\n  \u003CCard title=\"学んだ教訓\" icon=\"open-book\">\n    直面した課題、犯した過ち、そこから学んだこと。\n  \u003C/Card>\n\u003C/CardGrid>\n\n## 最近の投稿\n\n*ブログ記事は公開され次第ここに表示されます。最初のdev logをお楽しみに！*\n\n---\n\n*完全な英語版については、[開発ブログ](/blog)をご覧ください。*\n\n*最終更新: 2025-11-10*","src/content/docs/ja/blog/index.mdx","de0c38c8833d115e","ko/game",{"id":273,"data":275,"body":285,"filePath":286,"assetImports":287,"digest":288,"deferredRender":16},{"title":276,"description":277,"editUrl":16,"head":278,"template":18,"hero":279,"sidebar":283,"pagefind":16,"draft":39},"Bug Wars 플레이\n","Unity WebGL로 브라우저에서 Bug Wars를 경험하세요\n",[],{"tagline":280,"image":281,"actions":282},"무리에서 살아남아라. 당신의 가치를 증명하라.",{"alt":22,"file":204},[],{"hidden":39,"attrs":284},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n## 브라우저에서 Bug Wars 플레이\n\n궁극의 생존 도전에 대비하세요. Bug Wars는 Unity WebGL 기술을 사용하여 브라우저에서 직접 실행됩니다 - 설치 불필요.\n\n{/* Unity WebGL container will be injected here when the build is ready */}\n\u003Cdiv id=\"unity-game-wrapper\" style=\"margin: 2rem 0;\">\n  \u003Cdiv id=\"unity-loading-placeholder\" style=\"text-align: center; padding: 4rem 2rem; background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%); border-radius: 12px; border: 2px dashed rgba(99, 102, 241, 0.3);\">\n    \u003Ch3 style=\"margin-bottom: 1rem; color: #6366f1;\">Unity WebGL 빌드 곧 출시\u003C/h3>\n    \u003Cp style=\"color: #94a3b8; max-width: 600px; margin: 0 auto;\">\n      게임은 현재 개발 중입니다. Unity WebGL 빌드가 준비되면 여기에 임베드되어 즉시 브라우저 기반 게임플레이가 가능합니다.\n    \u003C/p>\n    \u003Cp style=\"margin-top: 1.5rem; font-size: 0.875rem; color: #64748b;\">\n      예상 기능: 완전한 3D 그래픽, 반응형 컨트롤, 웨이브 기반 전투, 몰입형 사운드 디자인.\n    \u003C/p>\n  \u003C/div>\n\u003C/div>\n\n## 게임 조작법\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"이동\" icon=\"right-arrow\">\n    WASD 또는 화살표 키를 사용하여 전장을 이동하고 적의 공격을 회피합니다.\n  \u003C/Card>\n  \u003CCard title=\"전투\" icon=\"rocket\">\n    왼쪽 클릭 또는 스페이스바로 공격. 타이밍을 맞춰 공격하여 데미지를 극대화하세요.\n  \u003C/Card>\n  \u003CCard title=\"특수 능력\" icon=\"star\">\n    E 또는 오른쪽 클릭으로 사용 가능한 특수 능력을 활성화합니다.\n  \u003C/Card>\n  \u003CCard title=\"일시정지 메뉴\" icon=\"setting\">\n    ESC를 눌러 게임을 일시정지하고 설정에 접근하거나 메인 메뉴로 돌아갑니다.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## 게임 팁\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"계속 움직이기\" icon=\"rocket\">\n    끊임없는 움직임이 생존의 열쇠입니다. 가만히 서 있으면 무리의 쉬운 표적이 됩니다.\n  \u003C/Card>\n  \u003CCard title=\"위협 우선순위\" icon=\"warning\">\n    가장 위험한 적부터 먼저 처리하세요. 일부 벌레는 다른 것들보다 더 많은 피해를 주거나 빠르게 움직입니다.\n  \u003C/Card>\n  \u003CCard title=\"자원 관리\" icon=\"star\">\n    특수 능력을 현명하게 사용하세요. 압도적인 상황이나 어려운 보스 전투를 위해 남겨두세요.\n  \u003C/Card>\n  \u003CCard title=\"패턴 학습\" icon=\"open-book\">\n    각 웨이브에는 예측 가능한 패턴이 있습니다. 적의 행동을 연구하여 공격을 예상하세요.\n  \u003C/Card>\n\u003C/CardGrid>\n\n---\n\n\u003Cdiv style=\"text-align: center; margin-top: 3rem; padding: 2rem; background: linear-gradient(135deg, rgba(239, 68, 68, 0.1) 0%, rgba(249, 115, 22, 0.1) 100%); border-radius: 12px;\">\n  \u003Ch3 style=\"margin-bottom: 0.5rem;\">싸울 준비가 되셨나요?\u003C/h3>\n  \u003Cp style=\"color: #94a3b8;\">벌레들이 기다리고 있습니다. 당신의 실력을 보여주세요.\u003C/p>\n\u003C/div>","src/content/docs/ko/game.mdx",[211],"6d51140a53dc5302","es/blog",{"id":289,"data":291,"body":297,"filePath":298,"digest":299,"deferredRender":16},{"title":292,"description":293,"editUrl":16,"head":294,"template":103,"sidebar":295,"pagefind":16,"draft":39},"Blog de Desarrollo de Bug Wars","Actualizaciones de desarrollo, conocimientos técnicos e historias detrás de escena del proyecto Bug Wars",[],{"hidden":39,"attrs":296},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Blog de Desarrollo de Bug Wars\n\n¡Bienvenido al blog de desarrollo de Bug Wars! Aquí compartimos actualizaciones sobre el progreso del juego, desafíos técnicos que hemos superado, decisiones de diseño y conocimientos sobre el proceso de desarrollo.\n\n## Qué Esperar\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"Análisis Técnicos\" icon=\"laptop\">\n    Explicaciones detalladas de los sistemas y tecnologías que impulsan Bug Wars, desde la arquitectura de Unity hasta las mecánicas de juego.\n  \u003C/Card>\n  \u003CCard title=\"Actualizaciones de Progreso\" icon=\"rocket\">\n    Actualizaciones regulares sobre nuevas funciones, mejoras e hitos mientras construimos el juego.\n  \u003C/Card>\n  \u003CCard title=\"Decisiones de Diseño\" icon=\"puzzle\">\n    Conocimientos sobre por qué tomamos decisiones específicas en el juego, la interfaz de usuario y la arquitectura técnica.\n  \u003C/Card>\n  \u003CCard title=\"Lecciones Aprendidas\" icon=\"open-book\">\n    Desafíos que hemos enfrentado, errores que hemos cometido y lo que aprendimos de ellos.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## Publicaciones Recientes\n\n*Las publicaciones del blog aparecerán aquí a medida que se publiquen. ¡Mantente atento a nuestro primer dev log!*\n\n---\n\n*Para la versión completa en inglés, visite el [Blog de Desarrollo](/blog).*\n\n*Última actualización: 2025-11-10*","src/content/docs/es/blog/index.mdx","c75e0da18548cc05","ko/blog",{"id":300,"data":302,"body":308,"filePath":309,"digest":310,"deferredRender":16},{"title":303,"description":304,"editUrl":16,"head":305,"template":103,"sidebar":306,"pagefind":16,"draft":39},"Bug Wars 개발 블로그","Bug Wars 프로젝트의 개발 업데이트, 기술적 통찰력, 비하인드 스토리",[],{"hidden":39,"attrs":307},{},"import { Card, CardGrid } from '@astrojs/starlight/components';\n\n# Bug Wars 개발 블로그\n\nBug Wars 개발 블로그에 오신 것을 환영합니다! 여기서는 게임의 진행 상황, 극복한 기술적 과제, 설계 결정, 개발 프로세스에 대한 통찰력을 공유합니다.\n\n## 기대할 수 있는 것\n\n\u003CCardGrid stagger>\n  \u003CCard title=\"기술적 심층 분석\" icon=\"laptop\">\n    Unity 아키텍처부터 게임플레이 메커니즘까지 Bug Wars를 구동하는 시스템과 기술에 대한 상세한 설명.\n  \u003C/Card>\n  \u003CCard title=\"진행 상황 업데이트\" icon=\"rocket\">\n    게임을 구축하면서 새로운 기능, 개선 사항 및 마일스톤에 대한 정기적인 업데이트.\n  \u003C/Card>\n  \u003CCard title=\"설계 결정\" icon=\"puzzle\">\n    게임플레이, UI 및 기술 아키텍처에서 특정 선택을 한 이유에 대한 통찰력.\n  \u003C/Card>\n  \u003CCard title=\"배운 교훈\" icon=\"open-book\">\n    직면한 도전, 저지른 실수, 그리고 그로부터 배운 것.\n  \u003C/Card>\n\u003C/CardGrid>\n\n## 최근 게시물\n\n*블로그 게시물은 게시되는 대로 여기에 표시됩니다. 첫 번째 dev log를 기대해 주세요!*\n\n---\n\n*전체 영문 버전은 [개발 블로그](/blog)를 방문하세요.*\n\n*최종 업데이트: 2025-11-10*","src/content/docs/ko/blog/index.mdx","ff6eacc036673e85"]